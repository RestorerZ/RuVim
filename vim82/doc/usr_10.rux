*usr_10.txt*	       для Vim version 8.2	      редакция от 22 ноя 2019

                  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
                              автор Брам Муленар

                       Расширенные приёмы правки текстов


В главе 4 рассказывалось об основных приёмах правки текстов. В этой главе
будет объяснено как работать с повторяющимися изменения или изменениями
затрагивающие большие объёмы текста, показаны приёмы, полезные при работе с
визуальными блоками, и использование внешних программ для выполнения сложных
операций.

|10.1|  Запись и повторное выполнение команд
|10.2|  Замена текста
|10.3|  Диапазоны для команд
|10.4|  Команда global
|10.5|  Режим визуального блока
|10.6|  Чтение и запись фрагментов файла
|10.7|  Форматирование текста
|10.8|  Изменение регистра символов
|10.9|  Использование внешних программ

 Следующая глава: |usr_11.txt|  Восстановление после аварии
Предыдущая глава: |usr_09.txt|  Использование графического интерфейса
      Содержание: |usr_toc.txt|

==============================================================================
*10.1*  Запись и повторное выполнение команд

Как уже говорилось ранее, команда `.` (точка) повторно выполняет предыдущую
команду по изменению текста. Но что делать, если необходимо повторно выполнить
нечто более сложное, чем единичная команда редактирования? Для этого
существует запись команд, которая выполняется в три простых этапа:

1. По команде "q{регистр}" начать запись нажатий клавиш в регистр {регистр}.
   Название регистра должно быть задано буквами в диапазоне от a до z.
2. Ввести требуемые команды.
3. Завершить запись, повторно нажав клавишу q (без дополнительных символов).

Теперь можно воспроизвести записанный макрос при помощи команды "@{регистр}".

Давайте попрактикуемся в использовании данного функционала. Предположим, в
тексте есть список файлов, который выглядит как:

        stdio.h ~
        fcntl.h ~
        unistd.h ~
        stdlib.h ~

и требуется получить следующее:

        #include "stdio.h" ~
        #include "fcntl.h" ~
        #include "unistd.h" ~
        #include "stdlib.h" ~

Прежде всего, установите курсор на первом символе первой строки. Затем введите
следующие команды:

        qa                      начало записи макроса в регистр a;
        ^                       перемещение курсора в начало строки;
        i#include "<ESC>        вставка строки #include " в начало строки;
        $                       перемещение курсора в конец строки;
        a"<ESC>                 добавление символа двойной кавычки (") в
                                конце строки;
        j                       переход к следующей строке;
        q                       окончание записи макроса.

Выполнив эти действия лишь один раз, можно повторить весь процесс для
остальных строк простым вводом команды `@a` три раза.
    Команда `@a` может предваряться числом-приставкой, которое задаёт
количество повторений выполнения макроса. В данном случае можно просто набрать
>
        3@a
<

ПЕРЕМЕЩЕНИЕ И ВЫПОЛНЕНИЕ

В случае если строки к которым необходимо применить записанную
макропоследовательность команд расположены в разных частях документа, то
переместите курсор к требуемой строке и введите команду `@a`. После первого
исполнения макроса, записанного в регистр a, его повторный вызов
осуществляется командой `@@`, что несколько быстрее при наборе. В случае если
после применения макрокоманды из регистра a был применён макрос записанный в
регистр b командой `@b`, то последующая команда `@@` будет вызывать
макрокоманду из регистра b.
    Сравнивая метод воспроизведения команд записанных в регистр, с методом
повторного выполнения посредством команды `.` обнаруживается несколько
различий. Во-первых, команда `.` может повторить только одну команду правки, а
команды вроде `@a` могут выполнять целые серии изменений, включая перемещение
курсора, как это видно из приведённого выше примера. Во-вторых, командой `.`
сохраняется только одно последнее изменение. При использовании же регистра
можно производить любые изменения текста не опасаясь, что содержащиеся в
регистре команды будет изменены. Наконец, в нашем распоряжении целых 26
регистров, что позволяет записать для последующего воспроизведения до 26
различных макрокоманд.


ИСПОЛЬЗОВАНИЕ РЕГИСТРОВ

Регистры, которые используются для записи макроса, — те же, что и для команд
копирования и удаления. Это позволяет использовать запись вместе с другими
командами, которые работают с регистрами.
    Предположим, в регистр "n было записано несколько команд. При
воспроизведении содержимого регистра с использованием команды `@n` вдруг
обнаруживается, что допущена ошибка в записанных командах. Можно, конечно,
записать макрос с самого начала, но кто даст гарантию, что не будет совершено
новых ошибок? Вместо этого, можно воспользоваться вот каким приёмом:

        G                   переместите курсор в конец файла;
        o<ESC>              создайте пустую строку;
        "np                 вставьте содержимое регистра "n в эту строку
                            (набранные команды будут отображаться как текст);
        {редактирование}    измените команды, в которых была допущена
                            ошибка так же, как редактируете обычный текст.
        0                   переместите курсор в начало строки;
        "ny$                скопируйте исправленную строку в регистр "n;
        dd                  удалите ненужную строку.

Теперь можно выполнять макрос с исправленными командами с помощью `@n`. (Если
записанные в макрос команды содержат перевод строк, то учтите этот факт в
предыдущем примере, когда будете копировать текст макроса в регистр, чтобы
скопировать все строки).


ДОБАВЛЕНИЕ В РЕГИСТР

При записи какропоследовательностей команд в регистр с наименованием заданным
строчной латинской буквой, предыдущее содержание указанного регистра будет
перезаписываться новыми командами. Для добавления к содержимому регистра
используйте прописные латинские буквы в названии регистра.
    Представьте, что в регистр "c записан макрос для изменения слова. Он
работает прекрасно, но теперь требуется добавить поиск следующего слова,
которое необходимо изменить. Этого можно добиться командой
>
        qC/слово<Enter>q
<
При указании команды `qC` будет выполнено дописывание команды в конец макроса,
который уже содержится в регистре "c. Таким образом, запись в регистр,
наименование которого задаётся прописной латинской буквой означает добавление
в регистр, наименование которого обозначается той же самой буквой, но
строчной.

Этот приём работает как с командами для записи макропоследовательностей, так и
с командами для копирования и удаления. Например, необходимо собрать
последовательность строк в регистр "a. Скопируйте первую строку при помощи
команды
>
        "aY
<
Теперь перейдите к следующей требуемой строке и наберите
>
        "AY
<
Эту команду можно повторить для всех строк, которые необходимо копировать.
Регистр "a теперь содержит все необходимые строки в том порядке, в котором они
были скопированы.

==============================================================================
*10.2*  Замена текста                          *find-replace* *поиск_и_замена*

По команде ":substitute" (замещение) будет выполнятся замена текста в
указанном диапазоне строк. В общем виде синтаксис этой команды следующий:
>
        :[диапазон]substitute/этот/этим/[флаги]
<
При вводе этой команды будет заменятся "этот" текст "этим" текстом во всех
строках, на которые указывает [диапазон]. Например, можно заменить "хакер"
словом "ламер" такой вот простой командой
>
        :%substitute/хакер/ламер/
<
        Примечание.
	Название команды :substitute почти никогда не вводится полностью. Чаще
	всего используется сокращённый вариант ":s". Далее мы также будем
	пользоваться сокращённой записью.

Значение диапазона заданное как "%", указывает на все строки текста. Без
указания диапазона команда ":s" применяется к текущей строке. Мы расскажем о
диапазонах подробнее в следующем параграфе |10.3|.

По умолчанию, ":substitute" заменяет только первое найденное слово "этот" в
строке. Например, предыдущая команда изменит строку

        Неожиданно, хакер Крутой заметил, что хакер Пупкин вошёл в сеть. ~

на

        Неожиданно, ламер Крутой заметил, что хакер Пупкин вошёл в сеть. ~

Чтобы заменить все совпадения в строке, необходимо добавить к команде флаг g
(global, повсюду). Команда
>
        :%s/хакер/ламер/g
<
изменит первоначальную строку на

        Неожиданно, ламер Крутой заметил, что ламер Пупкин вошёл в сеть. ~

Другие флаги, которые можно использовать с командой ":s", — p (print, печать)
для вывода последней строки, которая была изменена командой, c (confirm,
подтверждение) для запроса подтверждения перед выполнением замены. Введите
следующую команду:
>
        :%s/хакер/ламер/c
<
Будет найдено первое соответствие тексту "хакер" и выведен запрос с указанием
заменяющего его текста. Примерно такой запрос
>
	заменить словом ламер ? (y; n; a; q; l; CTRL+E; CTRL+Y)
<
В ответ на данный запрос необходимо указать один из предложенных вариантов:

        y           да (yes) — заменить;
        n           нет (no) — пропустить;
        a           все (all) — сделать эту замену и все последующие без
                    дальнейших запросов;
        q           выйти (quit) — не выполнять ни каких замен;
        l           последний раз (last) — сделать эту замену и завершить;
        CTRL-E      прокрутить текст на одну строку вверх;
        CTRL-Y      прокрутить текст на одну строку вниз.

В команде замены аргумент "этот" является на самом деле шаблоном, таким же,
как и тот, который используется в командах поиска. Например, при выполнении
следующей команды производится замена слова "хакер" только в том случае, если
оно появляется в начале строки
>
        :s/^хакер/ламер/
<
Если аргументы "этот" или "этим" команды замены содержат наклонную черту, то
перед ней необходимо добавить обратную наклонную черту, т. е. экранировать.
Более простой способ заключается в использовании другого символа в качестве
разделителя, например "+" (знак плюс)
>
        :s+один/два+один или два+
<
==============================================================================
*10.3*  Диапазоны для команд

Команда ":substitute", как и многие другие команды начинающиеся с : (двоеточие),
могут работать с диапазонами строк. Диапазон в самой простой форме выглядит
так: {номер},{номер}. Например, по команде
>
        :1,5s/этот/этим/g
<
будет выполнена замена на строках с номерами от 1 до 5 включительно. Диапазон
всегда указывается перед командой.

Одиночное число указывает на строку с определённым номером
>
        :54s/Хакер/Ламер/
<
Если не задан диапазон, то некоторые команды применяются ко всему файлу
целиком. Для таких команд можно использовать адрес ".", который указывает на
текущую строку. Например, к таким командам относится команда ":write". Без
указания диапазона будет выполнена запись всего файл. Напротив, по команде
>
        :.write другой_файл
<
будет выполнена запись в "другой_файл" только текущей строки.
    Первая строка всегда имеет номер 1, а последнюю строку можно обозначить
символом "$". Например, для замены текста от позиции курсора до конца файла
>
        :.,$s/да/нет/
<
Диапазон "%", о котором мы говорили выше, на самом деле просто сокращённая
форма для записи "1,$" — "от первой до последней строки в файле".


ИСПОЛЬЗОВАНИЕ ШАБЛОНОВ ПРИ УКАЗАНИИ ДИАПАЗОНА

Предположим, что редактируется книга и в одной из глав необходимо заменить все
слова "хакер" на слово "гик", но только в этой главе. Книга разбита на главы,
каждая из которых начинается со слова "Глава" расположенного в первой колонке
текста. Тогда можно выполнить такую команду: >

        :?^Глава?,/^Глава/s=хакер=гик=g

Обратите внимание, что шаблон поиска используется дважды. По первому шаблону
"?^Глава?" ищется строка, начинающуюся со слова "Глава" выше текущей позиции,
соответствующей заданному шаблону. Таким образом, диапазон ?шаблон?
используется для поиска в обратном направлении. Аналогично, шаблон "/^Глава/"
используется для поиска строки начинающейся со слова "Глава" вперёд по тексту
для поиска начала следующей главы. 
    Чтобы избежать путаницы с наклонной чертой, в команде замены в качестве
разделителя используется символ "=", но можно было бы использовать и наклонную
черту или другой символ.


СЛОЖЕНИЕ И ВЫЧИТАНИЕ

В указанной выше команде есть небольшая ошибка — если в заголовке следующей
главы есть слово "хакер", то оно будет также заменено. А если это не совсем
то, что нужно? В этом случае необходимо использовать смещение. 
    Для работы со строкой расположенной выше строки соответствующей заданному
шаблону, используют следующий приём
>
        /Глава/-1
<
Вместо единицы можно использовать любое другое число. Для адресации ко второй
строке расположенной ниже строки соответствующей шаблону, используют следующий
приём
>
        /Глава/+2
<
Смещения можно использовать и с другими элементами диапазона. Например,
>
        :.+3,$-5
<
указывает на то, что в диапазон будут включены строки, начиная с третьей
строки от текущей и заканчивая пятой строкой от последней строки в файле.


ИСПОЛЬЗОВАНИЕ ЗАКЛАДОК

Вместо вычисления номеров строк в тех или иных позициях для указания их в
диапазоне, можно применять закладки.
    Установите закладку в тексте, как об этом рассказано в главе 3. Например,
используйте закладку "mt" для верхней части области диапазона, и "mb" для
отметки нижней части. Теперь можно использовать закладки для указания строк
диапазона (в диапазон включаются и маркированные строки)
>
        :'t,'b
<

ВИЗУАЛЬНЫЙ РЕЖИМ И ДИАПАЗОНЫ

Если выделять текст в визуальном режиме и набрать ":" (двоеточие), чтобы
начать ввод команды, то в командной строке будет отображаться следующее
>
        :'<,'>
<
Теперь можно набрать команду и она будет применяться ко всему диапазону строк,
который был выбран визуально.

        Примечание.
        При использовании визуального режима для выбора части строки, или при
        использовании CTRL-V для выбора блока текста, команда с двоеточием всё
        равно будет применяться к целым строкам. Такое поведение возможно
        будет изменено в следующих версиях программы Vim.

Обратите внимание, что '< и '> это закладки, которые устанавливаются
автоматически в начальной и конечной позициях визуального выделения. Эти
закладки остаются в этих позициях до тех пор, пока не будет выполнено другое
выделение. Поэтому можно использовать команду `'<` для перемещения курсора к
позиции начала визуального выделения. Кроме того, эти закладки можно совместно
использовать с другими способами задания диапазона
>
        :'>,$
<
Данный диапазон указывает на строки от конечной позиции визуального выделения
и до конца файла.


ЧИСЛО СТРОК

Если точно известно сколько строк требуется изменить, то можно просто набрать
это число перед вводом символа ":" (двоеточие). Например, наберите "5:", и в
командной строке будет отображаться
>
        :.,.+4
<
Теперь можно набирать команды, которые необходимо использовать. Они будут
работать в диапазоне от "." (текущая строка) до ".+4" (ещё четыре строки
вниз), в итоге получается пять строк.

==============================================================================
*10.4*  Команда global

Команда ":global" является одной из самых выдающихся особенностей программы
Vim. Она позволяет найти соответствие шаблону и применить к найденному
указанную команду. Синтаксис этой команды следующий:
>
        :[диапазон]global/{шаблон}/{команда}
<
Выглядит очень похоже на команду ":substitute", но вместо замены текста,
совпадающего с шаблоном, на другой текст, выполняется команда {команда}.

        Примечание.
	В команде ":global" в качестве {команды} должна быть использована
	команда, начинающаяся с двоеточия. Команды режима команд не могут быть
	использованы в ":global" напрямую, но в этом случае может помочь
	команда |:normal|.

Предположим, что требуется поменять "foobar" на "barfoo", но только внутри
комментариев в стиле языка Си++, которые начинаются с символов "//". Для этого
используйте такую команду
>
        :g+//+s/foobar/barfoo/g
<
Разберёмся, что происходит. Команда начинается с ":g", что является
сокращением для ":global", точно так же как ":s" является сокращением для
":substitute". Далее следует шаблон, заключённый в символы "+", поскольку
шаблон, который мы ищем, содержит символ наклонной черты. И в завершении
команда замены, по которой будет заменён "foobar" на barfoo".
    Диапазоном для команды global по умолчанию является весь файл. Поэтому, в
этом примере не был указан диапазон, что отличает её от команды ":substitute",
в которой диапазоном по умолчанию считается текущая строка.
    Указанная команда не является пределом совершенства, поскольку также будет
находить появление "//" в середине строки и замены будут производиться перед
символами "//".

Как и в случае с ":substitute", можно использовать любой шаблон. Мы изучим
более сложные шаблоны позднее.

==============================================================================
*10.5*  Режим визуального блока

При помощи команды CTRL-V можно выполнить выделение прямоугольного блока
символов и существует несколько команд, выполняющих специальные операции с
такими блоками текста.

Команда `$` при использовании в режиме визуального блока работает несколько
иначе. Если `$` была последней командой, использованной для перемещения
курсора, то все строки визуального блока будут выделены вплоть до конца
строки, в том числе и в тех случаях, когда строка, в которой находится курсор,
была более короткой, чем остальные строки. Такое выделение будет оставаться в
силе до тех пор, пока не будут применены команды горизонтального перемещения
курсора, иными словами по команде `j` будет сохраняться такое поведение, а по
команде `h` будет отменено.


ВСТАВКА ТЕКСТА

По команде "I{строка}<Esc>" будет вставлен текст заданный {строка} в каждую
строку слева от границы визуального блока. Начните с выделения визуального
блока при помощи команды CTRL-V, переместите курсор в требуемое положение.
Теперь перейдите в режим вставки по команде `I` (прописная латинская буква I)
и введите текст для вставки. Во время набора текст будет появляться только в
первой строке.
    После нажатия клавиши <ESC> по окончанию ввода, текст будет вставлен во всех
строках, входящих в визуальный блок. Пример.

        include one~
        include two ~
        include three ~
        include four ~

Переместите курсор к символу "o" в слове "one" и нажмите CTRL-V. Далее,
переместите курсор на три строки вниз командой "3j", чтобы получился
визуальный блок на четыре строки. Теперь наберите
>
        Imain.<Esc>
<
В результате получится следующее:

        include main.one ~
        include main.two ~
        include main.three ~
        include main.four ~

Если блок проходит через короткие строки, которые не включаются в блок, то в
этих строках текст не будет вставлен. Например, сделайте выделение визуальным
блоком, включающее слово "очень" в первой и последней строке приведённого ниже
текста, и не затрагивая вторую строку:

        Эта строка очень длинная ~
        короткая ~
        Эта строка очень длинная ~

                   ^^^^^ выделенный блок

Теперь наберите команду "Iочень- <Esc>". В результате получится:

        Эта строка очень-очень длинная ~
        короткая ~
        Эта строка очень-очень длинная ~

В короткой строке текст не был вставлен.

Если в тексте, который вставляется, есть символ новой строки, то команда `I`
будет работать как обычная команда вставки режима команд и повлияет только на
первую строку помеченного блока.

Команда `A` (прописная латинская буква A) работает похожим образом, добавляя
введённый текст в каждой строке, справа от границы выделенного блока. И она
действительно добавляет текст к каждой строке, в том числе и коротким строкам.
Таким образом, есть выбор — добавлять текст к коротким строкам или нет.
    У команды `A` также есть одна особенность. Выделите визуальный блок и
воспользуйтесь командой `$` для расширения блока до границ строк. Теперь
по команде `A` будет добавляться введённый текст к концу каждой строки в
блоке, а не по правой границе выделенного блока.
   Используя пример, приведённый выше, наберите "$A !!!<Esc>" и получится
такой результат:

        Эта строка очень длинная !!! ~
        короткая !!! ~
        Эта строка очень длинная !!! ~

Для достижения такого эффекта требуется использование команды `$` для
перемещения курсора. Выполнение такого же выделения с помощью другой команды
перемещающей курсор в конец самой длинной строки, приведёт к иному результату.

ИЗМЕНЕНИЕ ТЕКСТА

По команде `c` в режиме визуального блока выполняется удаление блока и
переключение редактора в режим вставки. Набранный текст будет вставлен в
каждой строке, которая содержала выделенный блок.
    Используя всё тот же пример, наберите команду "c_ОЧЕНЬ_<Esc>", и получится
следующий результат:

        Эта строка _ОЧЕНЬ_ длинная~
        короткая ~
        Эта строка _ОЧЕНЬ_ длинная~

Как и в случае с командой `I`, короткая строка не была изменена. Аналогично,
чтобы это работало, в новом тексте нельзя вводить символ перевода строки.

По команде `C` (прописная латинская букв C) выполняется удаление текста от
левого края блока до конца строки и переключение редактора в режим вставки, в
котором можно ввести текст для добавления в конец каждой строки, текст которой
попал в выделение.
    Используйте наш пример ещё раз и наберите команду "Cс новым текстом<Esc>".
Заметьте, что даже если выделить слово "очень" лишь частично, оно всё равно
будет удалено полностью, поскольку с этой командой имеет значение только левый
край выделения:

        Эта строка с новым текстом ~
        короткая ~
        Эта строка с новым текстом ~

Короткая строка, которая не вошла в блок, не будет изменяться.

[Прим. перевод. Чтобы действие указанных в этом подразделе команд
соответствовало описанию, функциональность виртуальное редактирование должна
быть отключена для визуального блока]

Другие команды, изменяющие символы в блоке:

        ~       изменить регистр    (a -> A и A -> a)
        U       в верхний регистр   (a -> A и A -> A)
        u       в нижний регистр    (a -> a и A -> a)



ЗАПОЛНЕНИЕ СИМВОЛОМ

Для заполнения целого блока единичным символом используйте команду `r`.
Попробуйте на нашем примере ввести команду `rx`:

        Эта строка xxxxx длинная ~
        короткая ~
        Эта строка xxxxx длинная ~


        Примечание.
	Если требуется вставить символы вне границы строки в блоке, то
	прочитайте об особенности 'virtualedit' в главе 25.


СДВИГ

По команде `>` (знак больше) выполняется сдвиг выбранного текст вправо на
величину ширины сдвига, со вставкой пробельных символов. Начало сдвига
находится по левой границе визуального блока.
    Всё с тем же примером применение команды `>` даст следующий результат:

        Эта строка     очень длинная ~
        короткая ~
        Эта строка     очень длинная ~

Величина сдвига указывается в параметре 'shiftwidth'. Например, для установки
сдвига на 4 символа используйте команду
>
        :set shiftwidth=4
<
По команде `<` (знак меньше) удаляются пробельные символы с левого края блока
в количестве равном ширине одного сдвига. Эта команда ограничивается
количеством имеющегося текста. Если в тексте содержится пробелов меньше, чем
ширина сдвига, то будет удалено столько пробелов, сколько возможно.


ОБЪЕДИНЕНИЕ СТРОК

По команде `J` (прописная латинская буква J) выполняется объединение всех
выбранных строк в одну, с удалением символа перевода строки. В
действительности при этом происходит замена символа перевода строки, а также
предшествующих ему и последующих пробелов на один пробел. В конце предложения
вставляется два пробела (это можно изменить при помощи параметра 'joinspaces').
    Воспользуемся нашим примером. Результат использования команды `J` будет:

        Эта строка очень длинная короткая Эта строка очень длинная ~

Для применения команды `J` не требуется выделение блока. Она будет работать
точно также с командами `v` (посимвольный) и `V` (построчный) режимами визуального
выделения.

Если требуется, чтобы сохранялись начальные и конечные пробелы в объединяемых
строках, то используйте команду `gJ`.

==============================================================================
*10.6*  Чтение и запись фрагментов файла

Предположим, что при написании письма в него необходимо включить содержимое
другого файла. Это можно сделать при помощи команды ":read {название-файла}".
Текст, который содержится в файле, будет помещён под строкой с курсором.
    Допустим, в редакторе уже набран следующий текст:

        Ваня, привет! ~
        Лови diff, который исправляет глюки. ~

        Твой Петя. ~

Подведите курсор ко второй строке и наберите
>
        :read patch
<
Содержимое файла с названием "patch" будет вставлено в текст. Вот результат:

        Ваня, привет! ~
        Лови diff, который исправляет глюки. ~
        2c2 ~
        <       for (i = 0; i <= length; ++i) ~
        ---~
        >       for (i = 0; i < length; ++i) ~

        Твой Петя. ~

С командой ":read" можно также использовать диапазон, в этом случае содержимое
файла будет вставлено ниже последней строки диапазона. Так, по команде `:$r patch`
будет добавлено содержимое файла "patch" в конец редактируемого файла.
    А что делать, если необходимо поместить содержимое файла перед первой
строкой? Тогда используйте строку с номером ноль. Эта строка, конечно, в
реальности не существует, и при использовании цифры ноль в качестве диапазона,
в большинстве команд будет выдано сообщение об ошибке, но эта команда
разрешена
>
        :0read patch
<
Теперь содержимое файла "patch" вставлено в текст над первой строкой.


ЗАПИСЬ ДИАПАЗОНА СТРОК

Для записи диапазона строк в файл может быть использована команда ":write".
Без указания диапазона будет записан весь файл целиком, но если указать
диапазон, то будут сохранены только указанные строки, например,
>
        :.,$write tempo
<
При выполнении этой команды будут сохранены строки от текущей до последней в
файл "tempo". Если файл уже существует, то будет выдано сообщение об ошибке.
Таким образом редактором Vim применяется защита от случайной перезаписи
существующего файла. Если вы отдаёте себе отчёт в своих действиях, то
дополните команду флагом !, например,
>
        :.,$write! tempo
<
Внимание! Символ ! (восклицательный знак) должен следовать непосредственно за
командой ":write", без пробелов. В противном случае символ ! воспринимается
как команда-фильтр, которая объясняется далее в этой главе.


ДОБАВЛЕНИЕ В ФАЙЛ

В первом параграфе этой главы мы рассказали о том, как собрать несколько строк
в один регистр. То же самое можно сделать для сбора строк в файл. Запишите
первую строку при помощи команды
>
        :.write collection
<
Теперь переместите курсор ко второй строке и введите
>
        :.write >>collection
<
Символы ">>" после команды ":write" указывают программе Vim, что не надо
создавать новый файл "collection", а нужно добавить указанную строку в конец
существующего файла. Эту операцию можно повторять требуемое количество раз.

==============================================================================
*10.7*  Форматирование текста

При наборе обычного текста было бы неплохо, если бы длинные строки
автоматически переносились по ширине окна. Чтобы это происходило во время
набора, установите значение параметра 'textwidth' в требуемую длину строки.
Пример.
>
        :set textwidth=72
<
При разборе примера файла vimrc эта команда была задана для использования со
всеми текстовыми файлами, так что если применяется этот файл инициализации, то
данный параметр должен быть уже установлен. Чтобы проверить текущее значение
параметра 'textwidth', наберите
>
        :set textwidth
<
Теперь строки будут переноситься автоматически, если их длина превышает 72
символа. Однако, если выполняется вставка текста в середине строки или
удаление текста, то строки всё равно будут слишком длинными или слишком
короткими. В редакторе Vim не производится автоматическое форматирование
текста на лету. 
    Чтобы переформатировать текущий абзац, введите команду
>
        gqap
<
В этой команде вначале вводится оператор `gq`, а затем указание на текстовый
объект "ap", то есть "абзац". Абзац отделяется от следующего абзаца пустой
строкой.

        Примечание.
	Пустая строка, содержащая пробелы, не является разделителем абзацев.
	Будьте внимательны!

Вместо объекта "ap" можно использовать любую команду перемещения или иной
текстовый объект. Если абзацы разделены надлежащим образом, то для
форматирования целого файла используйте команду
>
        gggqG
<
Здесь по команде `gg` осуществляется переход к первой строке, `gq` это
оператор форматирования, а `G` это команда перемещения к последней строке.

В том случае, если абзацы в тексте не определены чётко, строки можно
форматировать вручную. Переместите курсор к первой строке, которую необходимо
отформатировать, и введите команду `gqj`, по которой будет отформатирована
текущая строка и строка расположенная под ней. Если текст в первой строке был
слишком короткой, то на эту строку будут добавлен текст из следующей строки.
Если текст был слишком длинный, то текст из этой строки будут перенесён на
следующую строку. Теперь можно использовать команду "." (точка) для повтора
команды форматирования до тех пор, пока не будет достигнут конец текста,
который требовалось отформатировать.

==============================================================================
*10.8*  Изменение регистра символов

Допустим, в тексте, в котором все заголовки параграфов набраны строчными
буквами, и необходимо, чтобы первое слово названия параграфа было набрано
прописными буквами, то для этого используйте оператор `gU`. Например,
>
                             gUw
<       первый параграф       ---->      ПЕРВЫЙ параграф ~

А оператор `gu` выполняет прямо противоположную операцию,
>
                             guw
<       ПЕРВЫЙ параграф        ---->     первый параграф ~

Для изменения регистра букв также можно использовать команду `g~`, которая
тоже является оператором, поэтому может работать с любыми командами
перемещения и текстовыми объектами, в том числе и в визуальном режиме.
    Чтобы оператор применялся ко всей строке, его обычно повторяют дважды.
Например, оператор удаления `d`, будучи набранным дважды, удаляет всю строку —
`dd`. Аналогично, по `gugu` преобразуется вся строка в нижний регистр
символов. Операторы `gugu` можно сократить до `guu`, `gUgU` до `gUU` и `g~g~`
до `g~~`. Пример.
>
                                     g~~
<       Девчонки ЛЮБЯТ Мороженое    ---->   дЕВЧОНКИ любят мОРОЖЕНОЕ ~

==============================================================================
*10.9*  Использование внешних программ

В редактор Vim встроено множество очень полезных и мощных команд, которые
могут делать с текстом почти всё. Тем не менее, могут существовать программы,
которые делают те или иные операции быстрее или лучше и можно работать с этими
программами напрямую из редактора Vim.
    По команде "!{перемещение}{программа}" берётся блок текста из редактора и
пропускается через внешнюю программу. Другими словами, по этой команде
запускается системная команда, указанная как {программа}, передаётся ей на
вход блок текста, выбранный {перемещением}. Вывод программы заменяет
отмеченный блок текста.
    Если ни когда не приходилось сталкиваться с работой фильтров в
UNIX-подобных системах, то, наверное, это сложно представить, давайте
рассмотрим это на примере. Программа sort сортирует текст в файле. Если
выполнить команду
>
        sort <input.txt >output.txt
<
, то несортированный файл "input.txt" будет отсортирован и записан в файл
"output".txt. (Это работает как в UNIX-подобных системах, так и в MS Windows).
    Теперь сделаем то же самое из редактора Vim. Допустим, необходимо
отсортировать строки файла с первой по пятую. Поместим курсор на первую
строку и введём команду
>
        !5G
<
По средством команды `!` редактор Vim уведомляется, что будет выполняться
операция фильтрации. Теперь он ожидает команды перемещения, которые укажут
ему, с какой частью текста надо провести эту операцию. Команда `5G` как раз
указывает редактору на перемещение к строке 5, так что теперь он знает, что
необходимо фильтровать строки с 1-ой по 5-ую. 
    В ожидании ввода команды-фильтра, курсор будет перемещён в командную строку
программы Vim и появится приглашение для ввода команды !. Теперь можно ввести
название команды-фильтра, в данном случае "sort". Полностью команда будет
выглядеть следующим образом
>
        !5Gsort<Enter>
<
В результате программой sort будет обработано первые пять строк текста. Вывод
программы заменяет то, что было в этих строках до того.

        строка 55                       строка 11
        строка 33                       строка 22
        строка 11        -->            строка 33
        строка 22                       строка 44
        строка 44                       строка 55
        последняя строка                последняя строка

По команде "!!" на обработку через программу-фильтр будет передаваться текущая
строка. В UNIX-подобных системах команда "date" выводит текущую дату и время.
Оператор "!!date<Enter>" указывает на замену текущей строки результатом
команды "date", что бывает полезно для добавления отметки о времени в текст
файла. 


ПОЧЕМУ ПРОГРАММЫ-ФИЛЬТРЫ МОГУТ НЕ РАБОТАТЬ

Запуск командной оболочки, отправка текста программе и получение вывода
требуют, чтобы редактор Vim был соответствующее настроен под работу командной
оболочки на используемой ЭВМ. Если возникают трудности с использованием
программ-фильтров, то проверьте значения следующих параметров:

        'shell'         название программы командной оболочки, используемой
                        редактором Vim для запуска внешних программ;
        'shellcmdflag'  аргумент, требуемый командной оболочке для выполнения
                        внешней программы;
        'shellquote'    тип кавычки в которые заключаются команды;
        'shellxquote'   тип кавычки в которые заключаются команды и
                        перенаправление вывода;
        'shelltype'     тип оболочки (только для Amiga);
        'shellslash'    использовать наклонную черту в командах (только для
                        MS Windows и подобных систем);
        'shellredir'    строка, используемая для перенаправления вывода
                        команд в файл.

В UNIX-подобных системах не должно возникнуть сложностей, потому что там всего
два основных типа оболочки: sh-подобные и csh-подобные. Редактором Vim
проверяется значение параметра 'shell' и автоматически устанавливаются
остальные параметры, значения которых зависят от того, встречается ли в
параметре 'shell' строка "csh".
    В системах MS Windows присутствует много различных оболочек и возможно,
потребуется настроить параметры вручную для правильной работы фильтров. За
дополнительной информацией по этим параметрам обращайтесь к документации.


СЧИТЫВАНИЕ ВЫВОДА КОМАНД

Чтобы получить содержимое текущего каталога и вставить эту информацию в файл,
используйте команду

в UNIX-подобных системах
>
        :read !ls
<
в MS Windows
>
        :read !dir
<

Вывод команды "ls" или "dir" перехватывается редактором и вставляется
непосредственно в текст под курсором. Это аналогично чтению файла, с тем
исключением, что используется команда `!` для указания команды, которую нужно
выполнить.
    Для команд можно задавать аргументы и использовать диапазон для указания
позиции, в которой редактором Vim должен быть помещён вывод. Например,
>
        :0read !date -u
<
будет вставлена текущая дата и время в формате UTC в верхней строке файла
(если в системе есть команда date, и она принимает аргумент "-u"). Обратите
внимание на различие между командой `!!date`, по которой заменяется строка в
тексте, и командой `:read !date`, по которой вставляется строка.


ПЕРЕДАЧА ТЕКСТА КОМАНДЕ

В UNIX-подобных системах команда "wc" используется для подсчёта слов. Чтобы
подсчитать слова в текущем окне, введите
>
        :write !wc
<
Используется всё та же команда ":write", но вместо названия файла указывается
команда `!` и название используемой внешней команды. В этом случае текст будет
передан внешней команде в виде стандартного ввода. Вывод команды может
выглядеть так:

        4      47     249 ~

Команда "wc" не очень многословна. Это означает, что в файле 4 строки, 47
слов и 249 символов. 

Будьте осторожны, чтобы не ввести >

        :write! wc

иначе текст будет записан в файл "wc" в текущем каталоге в обход всех
проверок. Пробел имеет здесь большое значение!


ОБНОВЛЕНИЕ ЭКРАНА

Если внешняя команда вывела сообщение об ошибке, то это может нарушить
отображение текста на экране. В редакторе Vim, для эффективности работы,
обновляются только те части экрана, которые в этом нуждаются, поэтому о том,
что внешняя программа вывела на экран сообщение, в редактор ни как не
передаётся. Чтобы в редакторе Vim обновить содержимое окна, нажмите комбинацию
клавиш
>
        CTRL-L
<

==============================================================================

Следующая глава: |usr_11.txt|  Восстановление после аварии
Авторские права: см. |авторские_права_на_документацию|  

vim:tw=78:ts=8:noet:ft=help:norl:
