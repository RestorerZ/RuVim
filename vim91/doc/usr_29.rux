*usr_29.txt*	       для Vim version 9.1	     редакция от 27 фев 2016

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

			Навигация по программному коду


Автор программы Vim по профессии является программистом. Поэтому не
удивительно, что в редакторе Vim так много возможностей, полезных при
написании компьютерных программ, это и переходы к месту определения тех или
иных переменных, и просмотр объявлений в отдельном окне, и многое другое, чему
посвящена эта и следующая глава руководства.

|29.1|  Работа с индексами
|29.2|  Окно просмотра
|29.3|  Перемещение в программном коде
|29.4|  Глобальный поиск идентификаторов
|29.5|  Локальный поиск идентификаторов

 Следующая глава: |usr_30.txt|	Редактирование текстов программ
Предыдущая глава: |usr_28.txt|	Структурирование текста
Содержание: |usr_toc.txt|

==============================================================================
*29.1*	Работа с индексами

Что такое «индекс»? Это позиция в тексте, где задан именованный идентификатор.
Например, определение функции в программе на языке Си или Си++. Индексы
хранится в специальном индексном файле и он используется программой Vim для
того, чтобы выполнять переходы непосредственно к позиции индекса, т. е. туда,
где определён именованный идентификатор, где бы в этот момент не находилась
каретка.
    Для создания базы индексов всех файлов языка Си из текущего каталога,
используйте команду

>
	ctags *.c
<

Здесь «ctags» — это отдельная программа и она включена во многие UNIX-подобные
системы. Если эта программа отсутствует, то можно получить Exuberant ctags из

    http://ctags.sf.net ~

Создав файл базы данных индексов, и запустив редактор Vim, можно перейти к
любому определению функции, как, например, показано в следующем примере:

>
	:tag startlist
<

По этой команде будет найдено определение функции «startlist», даже если это
сделано в другом файле.
    По команде CTRL-] выполняется переход к индексу, обозначенным словом,
расположенным в данный момент под кареткой. Это позволяет легко перемещаться
по клубку кода на языке Си. Например, находясь в функции «write_block» видите,
что она вызывает функцию «write_line». Но что делает эта функция «write_line»?
Поместив каретку на вызов функции «write_line» и нажав комбинацию клавиш
CTRL-], можно перейти к определению этой функции.
    В функции «write_line», в свою очередь, вызывается функция «write_char».
Теперь необходимо выяснить, что делает эта функция. Легко! Установите каретку
на вызове функции «write_char» и нажимаете комбинацию клавиш CTRL-]. Теперь
отображается определение функции «write_char».

	+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i < cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--> |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--> |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+

По команде ":tags" отображается перечень индексов, по которым были переходы

>
	:tags
<    №  на индекс	из строки   в файле или тексте ~
    1  1 write_line		8    write_block.c ~
    2  1 write_char		7    write_line.c ~
    > ~

Теперь вернёмся назад. По команде CTRL-T выполняется возврат к предыдущему
индексу. В нашем примере возврат будет в функцию «write_line», к месту вызова
функции «write_char».
    Эта команда принимает числовую приставку-аргумент, указывающую, на сколько
шагов надо вернуться назад. Давайте теперь опять выполним переход в
направлении «вперёд». По команде

>
	:tag
<

выполняется переход к индексу, находящемуся наверху перечня. Эта команда также
может предваряться числовым аргументом, указывающим количество переходов
вперёд, которое надо выполнить. Например, ":3tag". Как уже говорилось, то же
касается и команды CTRL-T.
    Таким образом, использование этих команд позволяет перемещаться вниз по
перечню индексов с помощью команды CTRL-], и вверх с помощью команды CTRL-T.
По команде ":tags" можно выяснить, где в перечне индексов находимся в данный
момент.


ПЕРЕХОД ПО ИНДЕКСУ С РЕЗУЛЬТАТОМ В НОВОМ ОКНЕ

По команде ":tag" выполняется замена файла, открытого в текущем окне на, тот,
в котором определён индекс. Но что, если необходимо видеть не только
определение старой функции, но и новую функцию, ту, из которой выполняется
переход к индексу? Для этого можно разделить окно по команде ":split" с
последующим выполнением команды ":tag". В редакторе Vim даже имеется
сокращённая команда для такой операции:

>
	:stag индекс
<

Для того чтобы выполнить разделение текущего окно и переход к индексу,
расположенному под кареткой, используйте команду

>
	CTRL-W ]
<

Если эта команда отдаётся с числовым аргументом-приставкой, то новое окно
будет высотой в указанное количество строк.


НЕСКОЛЬКО ФАЙЛОВ БАЗ ДАННЫХ ИНДЕКСОВ

Если файлы находятся в различных каталогах, то можно создать файлы баз данных
индексов в каждом из них. Изначально в редакторе Vim используется файл базы
индексов только из текущего каталога.
    Чтобы в редакторе Vim использовалось несколько файлов баз индексов,
настройте параметр 'tags' так, чтобы можно было найти все необходимые файлы.
Пример.

>
	:set tags=./tags,./../tags,./*/tags
<

В указанном примере будут использоваться файлы баз индексов в том же каталоге,
что и редактируемый файл, а также в каталоге, расположенном на один уровень
выше и во всех подкаталогах.
    Если не хватает даже этого, то в редакторе Vim реализован поиск файлов по
всему дереву файловой системы. Например, если редактируется файл в каталоге
«~/proj/src», а требуется использовать файл базы индексов в каталоге
«~/proj/sub/tags», то можно задать такую настройку параметра

>
	:set tags=~/proj/**/tags
<


ЕДИНЫЙ ФАЙЛ БАЗЫ ИНДЕКСОВ

Чтобы не растрачивать ресурсы системы и программы Vim на поиск и просмотр
файлов баз индексов по всему диску, можно создать единый файл базы индексов
для всего проекта, тем более что это потребует не так уж и много времени.
    Для этого потребуется программа Exuberant ctags. В ней реализована
возможность рекурсивного поиска определений, активируемая через задание
специального аргумента команды запуска. Пример.

>
	cd ~/proj
	ctags -R .
<

Приятной особенностью программы Exuberant ctags является и то, что она
распознаёт множество различных типов файлов. Для более тонкой настройки этой
программы, смотрите документацию к ctags.
    Теперь только требуется указать редактору, где находится созданный файл
базы индексов

>
	:set tags=~/proj/tags
<


НЕСКОЛЬКО СОВПАДАЮЩИХ ИНДЕКСОВ

Если функция определена несколько раз (или метод определён в нескольких
классах), то по команде ":tag" будет выполнен переход к первому определению в
списке. Если такое определение имеется в текущем файле, то переход произойдёт,
прежде всего, к этому определению.
    Для перехода к остальным индексам, которые соответствуют тому же самому
слову, следует использовать команду

>
	:tnext
<

Для поиска последующих определений, просто повторяйте эту команду. Если
перечень вариантов достаточно большой, то можно использовать команду

>
	:tselect индекс
<

В результате исполнения этой команды, в редакторе Vim будет выведено
сообщение:

    № пр. тип  индекс		файл	~
    1 F   f    mch_init	       os_amiga.c ~
		mch_init() ~
    2 F   f    mch_init	       os_mac.c ~
		mch_init() ~
    3 F   f    mch_init	       os_msdos.c ~
		mch_init(void) ~
    4 F   f    mch_init	       os_riscos.c ~
		mch_init() ~
    Введите номер и нажмите клавишу <ENTER> (если не указан, отмена): ~

При вводе номера (указан в первом столбце), будет выполнен переход к
требуемому индексу. Информация, указанная в других столбцах, поможет получить
представление о том, где определён этот индекс.

Для перехода от одного индекса к другому с тем же наименованием, можно
использовать следующие команды :

	:tfirst			переход к первому индексу в перечне;
	:[число]tprevious	переход к [число] предыдущему индексу;
	:[число]tnext		переход к [число] следующему индексу;
	:tlast			переход к последнему индексу в перечне.

Если [число] не указано, то считается, что оно равно 1.


ПОДСТАНОВКА НАИМЕНОВАНИЯ ИНДЕКСА

Чтобы не печатать длинное наименование индекса, можно воспользоваться
средствами подстановки в командной строке. Просто введите несколько символов
наименования индекса и нажмите клавишу <TAB>

>
	:tag write_<TAB>
<

Будет подставлен первый из возможных вариантов. Если это окажется не тот
индекс, который ожидался, то повторно нажмите клавишу <TAB>, пока не будет
подставлено то наименование, которое требуется.
    В случае, когда известна только часть наименования функции, или начало
наименований многих индексов совпадают, то в этих случаях можно использовать
шаблоны для поиска нужного индекса.
    Например, требуется перейти к индексу, наименование которого содержит
слово «block». Вначале наберите команду

>
	:tag /block
<

Далее, используя клавишу <TAB> для подстановки в командной строке, просмотрите
все предложенные варианты и выберете необходимый.
    При указании символа «/» перед названием индекса последующие символы будут
интерпретироваться не как буквальное наименование индекса, а как шаблон для
поиска. Допускается использование любых метасимволов в шаблонах поиска.
Например, если требуется найти индекс, наименование которого начинается со
слова «write_», то наберите команду

>
	:tselect /^write_
<

Через метасимвол "^", в начале шаблона, указывается, что название индекса
начинается с «write_». Без добавления этого метасимвола в шаблон поиска были
бы также найдены индексы, где это слово встречается в середине наименования
индекса. Аналогично, добавление метасимвола "$" в конце шаблона позволяет
гарантировать, что искомое слово соответствует окончанию наименования индекса.


ИСПОЛЬЗОВАНИЕ ИНДЕКСОВ ДЛЯ НАВИГАЦИИ

Как уже говорилось ранее, по команде CTRL-] выполняется переход по индексу,
наименование которого находится под кареткой. Это означает, что можно
использовать перечень наименований индексов для быстрого перемещения к их
определениям, подобно оглавлению в книге. Приведём пример.
    Прежде всего, создайте перечень именованных определений (для этого
потребуется Exuberant ctags)

>
	ctags --c-types=f -f functions *.c
<

Далее запустите программу Vim без аргументов командной строки и откройте файл
с этим перечнем в вертикально расположенном окне

>
	vim
	:vsplit functions
<

Теперь в окне отображается перечень всех функций, а также несколько
дополнительных элементов, которые можно игнорировать. Чтобы немного улучшить
вид перечня, введите команду `:setlocal ts=99`.
    Для удобства навигации в этом окне, лучше задать такую клавиатурную
команду:

>
	:nnoremap <buffer> <CR> 0ye<C-W>w:tag <C-R>"<CR>
<

Установите каретку на наименовании функции, которую требуется просмотреть, и
нажмите клавишу <ENTER>. В новом окне редактора Vim будет показано определение
этой функции.


ДОПОЛНИТЕЛЬНЫЕ СВЕДЕНИЯ

Чтобы в наименованиях индексов не учитывался регистр символов или измените
значение 'tagcase' на "ignore", или установите параметр 'ignorecase' при
действующем значении параметра 'tagcase' как "followic".

Через установку или сброс параметра 'tagbsearch', редактору Vim указывается,
что перечень индексов или сортирован, или не сортирован по алфавиту. По
умолчанию предполагается, что перечень сортирован, а это, в свою очередь,
позволяет искать необходимый индекс намного быстрее. В случае же установки
этого параметра окажется, что перечень на самом деле не сортированным по
алфавиту, то будут возникать ошибки при переходах к индексу.

Через параметр 'taglength' редактору Vim сообщается число символов, в пределах
которых распознаётся наименование индекса.

Свободная программа Cscope позволяет обнаружить не только место, где определён
тот или иной идентификатор, но и все места, где он используется. См. |cscope|.

==============================================================================
*29.2*	Окно просмотра

При правке кода, в котором есть вызов функций нужно следить за тем, чтобы не
было ошибок при указании её аргументов. Проще всего этого добиться, если во
время описания вызова функции можно увидеть её определение, да ещё и в
отдельном окне. И реализованный в редакторе Vim механизм работы с индексами
хорошо подходит для этого. Например, чтобы открыть окно просмотра с
определением функции «write_char», наберите следующую команду

>
	:ptag write_char
<

По этой команде будет выполнен переход по индексу "write_char" с отображением
результата в новом окне. При этом каретка останется в том окне, в котором была
до выполнения команды, и можно будет продолжить набор без необходимости
переключения между окнами командой CTRL-W.
    Если определение функции даётся в текущем файле, то увидеть его в окне
просмотра можно по команде

>
	CTRL-W }
<

В документации даётся пример программы, которая выполняет автоматическое
открытие окна просмотра, отображающее объявление, если слово под кареткой
является именованным индексом. Подробнее см. |CursorHold-example|.

Чтобы закрыть окно просмотра, используйте команду

>
	:pclose
<

Чтобы редактировать тот или иной файл в окне просмотра, используйте команду
":pedit". Это может быть полезно при редактировании заголовочного файла,
например,

>
	:pedit defs.h
<

Кроме того, можно использовать команду ":psearch" для поиска слова в текущем
либо подключаемом файле, и отображения результата в окне просмотра. Это
особенно полезно при использовании библиотечных функций, для которых может и
не быть файла базы индексов. Пример.

>
	:psearch popen
<

По этой команде в окне просмотра будет показан прототип функции popen() из
файла «stdio.h»:

    FILE    *popen __P((const char *, const char *)); ~

Через параметр 'previewheight' можно настроить высоту окна просмотра при его
открытии.

==============================================================================
*29.3*	Перемещение в программном коде

Поскольку исходные тексты программ хорошо структурированы, то в редакторе Vim
реализован механизм распознавания их отдельных элементов и специальные команды
для перемещения между ними. Программы на языке Си часто содержат конструкции
наподобие следующей:

	#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~

Зачастую такого рода конструкции намного длиннее показанной; кроме того, такие
конструкции могут быть вложены одна в другую. Опишем, как можно работать с
подобными конструкциями. Установите каретку на слове «#ifdef» и нажмите
клавишу "%", будет выполнен переход к строке со словом «#else». Повторное
нажатие клавиши "%" вызовет переход к слову «#endif», если сейчас ещё раз
нажать клавишу "%", то каретка будет возвращена на строку со словом «#ifdef».
    Если конструкция будет вложена в другую похожую конструкцию, то будет
найдено правильное соответствие искомому слову. Этот способ хорошо годится для
проверки незакрытых ключевых слов «#if» и подобных ему.
    Если каретка находится где-то внутри конструкции «#if» — «#endif», то
можно переместить её к началу этого блока с помощью команды

>
	[#
<

В случае если при исполнении этой команды каретка не находится где-либо после
слова «#if» или «#ifdef», то в редакторе Vim будет выдан звуковой сигнал. Для
перехода к следующему слову «#else» или «#endif» используйте команду

>
	]#
<

При исполнении этих двух команд будут проигнорированы вложенные конструкции
«#if» — «#endif». Пример.

	#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~

Если каретка находится на последней строке в примере, то по команде `[#`
каретка будет перемещена на первую строку. Конструкция из «#ifdef» — «#endif»
внутри внешней конструкции будет пропущена.


ПЕРЕМЕЩЕНИЕ ВНУТРИ БЛОКОВ ИЗ ФИГУРНЫХ СКОБОК

В языке Си блоки команд заключаются в фигурные скобки, и такие гирлянды блоков
могут быть достаточно длинными. Для перемещения к началу внешнего блока
используйте команду `[[`. По команде `][` будет выполнено перемещение к
завершению внешнего блока. Для успешного исполнения этих команд обязательным
условием является размещение символов «{» и «}» в первых колонках строк.
    По команде `[{` выполняется перемещение каретки в начало текущего блока
команд, а по команде `]}` — переход к окончанию текущего блока. При исполнении
этих команд будут игнорироваться вложенные пары фигурных скобок. Вот схема,
которая поможет разобраться в этих командах:

			function(int a)
	   +->		{
	   |		    if (a)
	   |	   +->	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +->	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 <-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       <-+	 |
			}				       <-+

При написании программ на языках Си++ или Java во внешнем блоке команд,
заключённого в фигурные скобки, описывается класс. Следующий уровень блока
команд в фигурных скобках относится к методу. Внутри описания класса, чтобы
перейти к началу предыдущего метода, можно использовать команду `[m`, а по
команде `]m` каретка будет перемещена к началу следующего метода.

Кроме того, по команде `[]` каретка будет перемещена назад к окончанию
функции, а по команде `]]` — вперёд к началу следующей функции. Окончание
функции определяется по закрывающей фигурной скобке расположенной в первой
колонке строки.

				int func1(void)
				{
					return 1;
		  +---------->  }
		  |
	      []  |		int func2(void)
		  |	   +->	{
		  |    [[  |		if (flag)
	отсюда	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +->	}
	      ]]  |
		  |		int func3(void)
		  +---------->	{
					return 3;
				}

Не забывайте, что можно также использовать и команду `%` для перемещения между
соответствующими парами (), {} и [] скобок. Эта команда работает даже тогда,
когда соответствующие скобки разнесены друг от друга на много строк.


ПЕРЕМЕЩЕНИЕ ВНУТРИ БЛОКОВ ИЗ КРУГЛЫХ СКОБОК

Команды `[(` и `])` работают так же, как и команды `[{` и `]}`, с тем
исключением, что они позволяют перемещаться внутри блока круглых скобок, а не
внутри блока фигурных скобок.
>
				  [(
<		    <--------------------------------
			      <-------
		if (a == b && (c == d || (e > f)) && x > y) ~
				  -------------->
			  --------------------------------> >
				       ])
<

ПЕРЕМЕЩЕНИЕ ПО БЛОЧНЫМ КОММЕНТАРИЯМ

Для перемещения назад к началу комментария, используйте команду `[/`. Чтобы
перемещение было выполнено вперёд к окончанию комментария, используйте команду
`]/`. Эти команды работают для комментариев в стиле /* - */.

	  +->	  +-> /*
	  |    [/ |    * Комментарий о        --+
       [/ |	  +--  * прекрасной жизни.	| ]/
	  |	       */		      <-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* ещё комментарий */  <-+

==============================================================================
*29.4*	Глобальный поиск идентификаторов


Представьте, что при редактировании программы на языке Си необходимо выяснить
объявлена ли переменная как «int» или как «unsigned». Быстрый способ выяснить
это — использовать команду `[I`.
    Предположим, каретка находится на слове «column». Наберите команду

>
	[I
<

и в редакторе Vim будут показаны все строки с этим идентификатором. Причём
этот идентификатор будет найден не только в текущем файле, но и во всех
подключаемых файла (а также в подключаемых файлах этих подключаемых файлов и
т. д.). Результат может выглядеть примерно так:

    structs.h ~
    1:   29     unsigned     column;    /* column number */ ~

Преимущество этого метода перед использованием индексов или окна просмотра
состоит в том, что поиск также ведётся в подключаемых файлах. В большинстве
случаев это приводит к тому, что сразу видно как была объявлена та или иная
переменная. Кроме того, этот способ помогает в тех случаях, когда файл базы
индексов не соответствует действительности, или если нет файла базы индексов
для подключаемых файлов.
    Однако, чтобы эта команда работала, должно быть соблюдено несколько
условий. Прежде всего, в параметре 'include' должно быть указано, каким
способом выполняется подключение файлов. Значение этого параметра по умолчанию
соответствует способу, используемому в языках Си и Си++. Для других языков
программирования, возможно, придётся изменить значение этого параметра.


МЕСТОНАХОЖДЕНИЕ ПОДКЛЮЧАЕМЫХ ФАЙЛОВ

Механизмом обнаружения подключаемых файлов, встроенным в редактор Vim,
используются значения параметра 'path' для поиска этих файлов. Если тот или
иной каталог не указан в значении этого параметра, то некоторые подключаемые
файлы могут быть не обнаружены. Проще всего проверить, как обстоят дела, при
помощи команды

>
	:checkpath
<

Будет представлен перечень подключаемых файлов, местонахождение которых не
найдено, включая файлы, которые указаны как подключаемые в тех файлах,
местонахождение которых распознано. Пример вывода команды:

-- Подключаемые файлы, не найденные в каталогах заданных в параметре 'path' -- ~
    <io.h> ~
    vim.h --> ~
	<functions.h> ~
	<clib/exec_protos.h> ~

Файл «io.h» подключается из текущего файла, но не найден. Файл «vim.h»
обнаружен, поэтому по команде ":checkpath" проверяются файлы, подключаемые из
этого файла, и сообщается, что среди них не найдены файлы «functions.h» и
«clib/exec_protos.h».

	Примечание.
	Программа Vim это не компилятор. Редактором не распознаются директивы
	«#ifdef» при поиске подключаемых файлов, а используются все выражения
	«#include», которые могут быть найдены, даже если они находятся после
	выражения вроде «#if NEVER».

Для того чтобы исправить ситуацию, добавьте необходимый каталог в параметр
'path'. Посмотрите в файле Makefile, скорее всего там уже перечислены все
необходимые маршруты, которые обычно  указываются с помощью ключа "-I",
например, «-I/usr/local/X11». Чтобы добавить этот каталог, введите команду

>
	:set path+=/usr/local/X11
<

Если подкаталогов несколько, то можно использовать символ маски "*". Пример.

>
	:set path+=/usr/*/include
<

По этому шаблону будет выполняться поиск как в каталоге «/usr/local/include»,
так и в «/usr/X11/include».

При работе над проектом, в котором есть множество подкаталогов с подключаемыми
файлами, полезна также маска "**". При указании этой маски, поиск также будет
выполняться во всех подкаталогах. Пример.

>
	:set path+=/projects/invent/**/include
<

По этому шаблону будет выполняться поиск в таких каталогах, как:

	/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	и т. п.

Есть возможность указывать и другие шаблоны. Дополнительную информацию
смотрите в документации по параметру 'path'.
    Если необходимо посмотреть, все найденные подключаемые файлы, то
воспользуйтесь командой

>
	:checkpath!
<

По этой команде будет отображён перечень подключаемых файлов, который,
возможно, будет объёмным. Чтобы немного сократить этот перечень, в нём будут
отмечаться файлы, которые уже были показаны, как «(уже показано)».


ПЕРЕХОД К НАЙДЕННОМУ ИДЕНТИФИКАТОРУ

По команде `[I` будет отображён список, в котором представлена только та
строка, в которой присутствует искомый идентификатор, а для просмотра соседних
с ней строк нужно перейти на строку, представленную в списке. Например, чтобы
перейти к первой строке из списка, введите команду

>
	[<TAB>
<

При наборе этой команды можно использовать и следующую последовательность
нажимаемых клавиш: «[CTRL-I», поскольку нажатие комбинации клавиш CTRL-I и
клавиши <TAB> интерпретируются одинаково.

Список, выдаваемый по команде `[I`, включает номер, который выводится в начале
каждой строки. Если требуется перейти к строке, имеющей отличный от единицы
номер в списке, то укажите этот номер перед вводом команды

>
	3[<TAB>
<

После ввода этой команды будет выполнен переход к третьей строке,
представленной в списке. Не забывайте, что для возвращения назад можно
использовать команду CTRL-O.


СВЯЗАННЫЕ КОМАНДЫ

	[i		будет показано только первое совпадение
	]I		будут показаны только совпадения, расположенные ниже
			по тексту от позиции каретки
	]i		будет показано только первое совпадение ниже по тексту


ПОИСК ОПРЕДЕЛЕНИЙ ЗАДАННЫХ ЧЕРЕЗ ДИРЕКТИВУ #define

Обратите внимание, что по команде `[I` выполняется поиск любых идентификатор.
Для поиска только определений макрокоманд, заданных через директиву «#define»,
используйте команду

>
	[D
<

Поиск будет выполняться также и во всех подключаемых файлах. Настроить
синтаксис макроопределений можно с помощью параметра 'define', который по
умолчанию настроен на синтаксис в стиле языков программирования Си и Си++.
Команды, связанные с командой `[D`:

	[d		будет показано только первое совпадение
	]D		будут показаны только совпадения, расположенные ниже
			по тексту от позиции каретки
	]d		будет показано только первое совпадение ниже по тексту

==============================================================================
*29.5*	Локальный поиск идентификаторов

Как уже говорилось, по команде `[I` выполняется поиск также и во всех
подключаемых файлах. Для поиска только в тексте текущего файла и перехода к
первой позиции, где было использовано слово, находящееся под кареткой,
используйте команду

>
	gD
<

Эта команда перехода к определению («Goto Definition»). Она очень полезна для
поиска локальных переменных и функций, говоря языком Си — «статических».
Приведём пример (каретка находится на слове «counter»):

	   +->   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }

Если требуется ещё больше ограничить поиск определения границами текущей
функции, то используйте команду

>
	gd
<

По этой команде будет переход к началу текущей функции, и затем попытка найти
первое появление идентификатора ниже позиции каретки. Если более точно, то по
этой команде выполняется перемещение каретки назад к первой пустой строке
перед символом «{» в первой колонке, и уже с этой позиции производится поиск
идентификатора. Приведём пример (каретка на «idx»):

		int find_entry(char *name)
		{
	   +->	    int idx;
	   |
	gd |	    for (idx = 0; idx < table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}

==============================================================================

Следующая глава: |usr_30.txt|  Редактирование текстов программ
Авторские права: см. |manual-copyright|  
© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

vim:tw=78:ts=8:noet:ft=help:norl:
