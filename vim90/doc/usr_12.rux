*usr_12.txt*	       для Vim version 9.0	      редакция от 11 авг 2017

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

			   Интересные приёмы работы


Сочетая различные команды редактора Vim можно делать с текстом практически
всё, что угодно. В этой главе будет показано несколько таких полезных приёмов,
с использованием команд, которые обсуждались в предыдущих главах, а также
нескольких новых команд.

|12.1|  Замена слова
|12.2|  Замена «Фамилия, Имя» на «Имя Фамилия»
|12.3|  Сортировка списка
|12.4|  Обратный порядок строк
|12.5|  Подсчёт слов
|12.6|  Поиск в справочнике man
|12.7|  Удаление лишних пробелов
|12.8|  Поиск строк, где используется слово

 Следующая глава: |usr_20.txt|  Быстрый набор в командной строке
Предыдущая глава: |usr_11.txt|  Восстановление после аварийных ситуаций
      Содержание: |usr_toc.txt|

==============================================================================
*12.1*  Замена слова

Команда ":substitute" может быть использована для замены одного слова на
другое по всему тексту. Пример.

>
	:%s/три/3/g
<

Где диапазон «%» указывает на весь файл, а флаг 'g' расширяет действие команды
на замену всех слов в строке. Однако если в файле также имеются слова вроде
«сотри», то они также будут заменены, и получится такое «со3». Это не то, что
нужно, и чтобы этого избежать, используйте в шаблоне метасимвол "\<", для
указания признака начала слова

>
	%s/\<три/3/g
<

Но, тем не менее, ошибка все равно возможна в словах вроде «тринадцать». Чтобы
указать признак окончание слова, используйте в шаблоне метасимвол "\>"

>
	%s/\<три\>/3/g
<

Если это, например, текст программы, то, возможно, необходимо заменить «три»
только в комментариях. Чтобы долго не мучиться с изобретением шаблона,
используйте флаг 'c', чтобы запрашивалось подтверждение перед каждой заменой
командой ":substitute"

>
	:%s/\<four\>/4/gc
<


ЗАМЕНА СЛОВА В НЕСКОЛЬКИХ ФАЙЛАХ

Предположим, что необходимо заменить слово в нескольких файлах. Для этого
можно открыть каждый файл и в каждом из них набрать требуемую команду вручную.
Но быстрее воспользоваться записью команды и её последующим воспроизведением.
    Пусть имеется каталог с файлами исходных текстов программ на языке
программирования Си++, названия которых заканчиваются на «.cpp», и в этих
файлах есть функция «GetResp», которую требуется переименовать в «GetAnswer».

	vim *.cpp		Запустите редактор Vim со списком аргументов,
				состоящим из всех файлов Си++. Будет открыт
				первый файл из списка.
	qq			Начните запись макрокоманды в регистр "q.
	:%s/\<GetResp\>/GetAnswer/g
				Сделайте необходимые замены в первом файле.
	:wnext			Сохраните этот файл и перейдите к следующему.
	q			Остановите запись.
	@q			Выполните макрос из регистра "q, в результате
				чего будут произведены необходимые замены и
				выполнена команда ":wnext". Убедитесь, что
				не возникает сообщений об ошибке.
	999@q			Запустите макрос из регистра "q для остальных
				файлов.

На последнем файле будет выведено сообщение об ошибке, поскольку по команде
":wnext" не будет выполнен переход к следующему файлу. В результате, работа
макроса будет остановлено, а все требуемые замены будут произведены.

	Примечание.
	При воспроизведении записанной последовательности команд, ошибка в
	одной из них, вызывает остановку исполнения всего макроса. Поэтому
	убедитесь, что во время записи команды, ошибок не возникает.

Здесь есть одна деталь. Если в одном из файлов «.cpp» нет слова «GetResp», то
будет выведено сообщение об ошибке, и выполнение макроса будет остановлено.
Чтобы этого избежать, установите в команде замены флаг 'e'

>
	:%s/\<GetResp\>/GetAnswer/ge
<

Флаг 'e' изменят поведение команды ":substitute" таким образом, что отсутствие
соответствий шаблону не считается ошибкой.

==============================================================================
*12.2*  Замена «Фамилия, Имя» на «Имя Фамилия»

Имеется список имён в следующем виде:

    Пупкин, Василий ~
    Сидоров, Пётр ~

Необходимо, чтобы список выглядел так:

    Василий Пупкин ~
    Пётр Сидоров ~

Эта операция может быть проделана одной-единственной командой:

>
	:%s/\([^,]*\), \(.*\)/\2 \1/
<

Давайте разберёмся. Само собой, это команда замены ":substitute", где диапазон
«%» указывает на все строки в файле и замены будут произведены во всём файле.
    Аргументы команды ":substitute" указываются в форме «/что/чем/». Наклонная
черта разделяет шаблон "что" и строку "чем". Вот что содержит шаблон «что»:

							\([^,]*\), \(.*\) ~
В первой части, отвечающей за искомую «Фамилию»,
между \( \) указано, что шаблон:                        \(     \)
    соответствует любому символу, кроме запятой           [^,]
    повторяется любое количество раз			      *
Далее указывается буквальное соответствие символу «,»            ,
Во второй части, отвечающей за искомое «Имя»,
между \( \) указано, что шаблон:				   \(  \)
    соответствует любому символу				     .
    повторяется любое количество раз				      *

В аргументе «чем» есть записи "\2" и "\1". Такое обозначение называется
«обратная ссылка». Они ссылаются на текст, который соответствует частям
шаблона заключённого в круглые скобки «\( \)». Ссылка "\2" указывает на вторую
часть шаблона в «\( \)», т. е. отвечающую за искомое «Имя». Ссылка "\1"
указывает на первую часть шаблона в «\( \)», т. е. отвечающую за искомую
«Фамилию».
    Можно использовать до девяти обратных ссылок в аргументе «чем» команды
":substitute". Ссылка "\0" указывает на весь шаблон поиска. В команде
":substitute" можно использовать и другие метасимволы, см.
|спецсимволы_для_замены|.

==============================================================================
*12.3*  Сортировка списка

В сборочных файлах Makefile часто встречаются списки файлов. Например,

    OBJS = \ ~
    version.o \ ~
    pch.o \ ~
    getopt.o \ ~
    util.o \ ~
    getopt1.o \ ~
    inp.o \ ~
    patch.o \ ~
    backup.o ~

Отсортируем перечень этх файлов через внешюю программу "sort":

>
	/^OBJS
	j
	:.,/^$/-1!sort
<

По первой команде в приведённом выше примере выполняется переход к первой
строке, которая начинается со слова «OBJS», затем, по следующей команде,
каретка перемещается на строку вниз и наконец, по третьей команде, выполняется
прогон через фильтр всех строк вплоть до следующей пустой строки. Можно было
бы также выделить строки в визуальном режиме и затем использовать оператор
"!sort". Это было бы нагляднее, но если строк слишком много, то требует больше
усилий.
    Результат работы команды-фильтра:

    OBJS = \ ~
    backup.o ~
    getopt.o \ ~
    getopt1.o \ ~
    inp.o \ ~
    patch.o \ ~
    pch.o \ ~
    util.o \ ~
    version.o \ ~

Обратите внимание, что обратная наклонная черта в конце строк указывает на
продолжение строки. После сортировки расположение этого символа оказалось
нарушено! Строка «backup.o», которая находилась в конце списка, не имела
обратной наклонной черты, а теперь, когда она находится в верхней части
списка, должна её иметь.
    Самое простое решение будет добавить обратную наклонную черту при помощи
команды "A \<ESC>". Что касается наличия обратной наклонной черты в последней
строке, то она не мешает, если после неё есть пустая строка. В этом случае,
при повторной сортировке, проблемы больше не возникнет.

==============================================================================
*12.4*  Обратный порядок строк

Командой |:global| в сочетании с командой |:move| может быть выполнено
перемещение всех строк по очереди в позицию перед первой строкой, чтобы
получился файл с обратным порядком строк. Команда выглядит так:

>
	:global/^/move 0
<

Сокращённая запись команды:

>
	:g/^/m 0
<

Метасимвол регулярного выражения "^" в данном случае соответствует началу
строки, даже в том случае, если строка пустая. По команде |:move| перемещаются
соответствующие строки в позицию после мифической нулевой строки, так, что
текущая строка становится первой строкой в файле. Поскольку в команде
|:global| не учитывается изменившаяся нумерация строк, то продолжается
выполнение этой команды и строки в файле считываются одна за другой, и
переносятся снизу вверх.

Подобные операции будут также работать и с диапазоном строк. Переместите
каретку в положение над первой строкой и отметьте эту позицию при помощи
команды "mt". Затем переместите каретку к последней строке в диапазоне и
введите команду

>
	:'t+1,.g/^/m 't
<

==============================================================================
*12.5*  Подсчёт слов

Иногда требуется написать текст, в котором было бы как можно больше слов.
Редактором Vim может быть выполнен подсчёт слова в файле.
    Для подсчёта слов в файле используйте команду

>
	g CTRL-G
<

Вывод команды выглядит примерно следующим образом:

    Колонка 1 из 0; строка 141 из 157; слово 748 из 774; байт 4489 из 4976 ~

Таким образом, можно видеть на каком по счёту слове находится в данном случае
каретка (748) и сколько слов всего в файле (774).

Если текст, в котором надо посчитать слова, занимает не весь файл, то вместо
того, чтобы проводить в уме вычисления разности между двумя значениями в
разных позициях файла, достаточно выделить необходимый фрагмент в визуальном
режиме, и затем дать команду g CTRL-G. Вот как может выглядеть результат:

    Выделено: строк 5 из 293; слов 70 из 1884; байт 359 из 10928 ~

Другие способы подсчёта слов, строк и других элементов обсуждаются в параграфе
|подсчёт_элементов_текста|.

==============================================================================
*12.6*  Поиск в справочнике man
						*find-manpage*  *поиск_в_man*

При редактировании командных файлов оболочки или программы на языке Си порой
требуется посмотреть для какой-нибудь команды или функции страницу справочника
man (в UNIX-подобных системах). Для этого есть достаточно простой способ:
установите каретку на слово, по которому требуется выполнить поиск, и нажмите
клавишу

>
	K
<

Редактором Vim будет выполнен вызов внешней программы "man" с данным словом в
качестве аргумента и если справочная страница man будет найдена, то она будет
показана. Для отображения страниц используется стандартная программа-пейджер,
например "more". После прочтения документации, нажмите клавишу <ENTER> для
возврата в редактор Vim.

К сожалению, при этом способе нельзя видеть страницу man и текст, над которым
ведётся работа, одновременно, однако существует способ позволяющий открывать
страницу man прямо в окне редактора Vim. Для этого запустите внешний модуль
для типа фала man

>
	:runtime! ftplugin/man.vim
<

Если будете часто использовать этот способ, то поместите указанную команду в
файл vimrc. Теперь попробуйте набрать команду ":Man", чтобы открыть справочные
страницы man в окне редактора Vim.

>
	:Man csh
<

Само собой, синтаксис будет подсвечиваться. Для возврата в окно с текстом, с
которым работаете, нажмите "CTRL-W w". Для поиска страницы man из
какого-нибудь конкретного раздела, используйте обычный синтаксис. Например,
для «echo» в разделе 3.

>
	:Man 3 echo
<

Для перехода по перекрёстным ссылкам на справочных страницах man, например,
«word(1)», нажимайте комбинацию клавиш CTRL-] на ссылке. Дальнейшие вызовы
команды ":Man" будет использовать то же самое окно.

Чтобы показать страницу для слова, на котором находится каретка, используйте
команду

>
	\K
<

(Если символ <Leader> был переопределён, то используйте этот символ вместо
обратной наклонной черты). Например, если хотите посмотреть, что возвращает
функция «strstr()» во время редактирования примерно такого участка кода:

    if ( strstr (input, "aap") == ) ~

, то подведите каретку к «strstr» и введите "\K". Откроется окно, со страницей
справочника для функции «strstr()».

==============================================================================
*12.7*  Удаление лишних пробелов

Некоторые люди считают пробелы и символы табуляции в конце строки бесполезными
и бестолковыми. Наверное, они где-то и правы, и чтобы удалить лишние пробелы в
конце каждой строки, используйте команду

>
	:%s/\s\+$//
<

В приведённой команде в качестве значения диапазона использован символ «%»
(процент), что указывает на обработку всех строк в файле. Шаблон, совпадение с
которым ищет команда ":substitute" — "\s\+$". Этот шаблон соответствует 1 или
большему количеству (\+) пробельных символов (\s) перед концом строки ($). Как
составлять такие шаблоны будет объяснено далее, в главе |usr_27.txt|. Аргумент
«чем», команды ":substitute", пустой — "//". Таким образом, замена выполняется
ни чем, просто удаляя все пробелы, совпадающие с шаблоном.

Другой пример бестолкового использования пробелов — перед символом табуляции.
Часто эти пробелы можно удалить без всякого вреда, но не всегда! Поэтому лучше
всего делать это вручную, при помощи команды поиска

>
	/ 	
<

Кажется, что здесь ни чего нет, но здесь действительно пробел перед символом
табуляции, или как‐то так "/<Space><Tab>". Попробуйте удалить найденные
пробелы командой `x`, следя за тем, чтобы ширина пустого пространства не
изменялось. Если это произойдёт, то, возможно, потребуется вставить ещё один
символ табуляции. Для перехода к следующему совпадению с шаблоном поиска,
нажмите клавишу "n". Операцию нужно будет повторить до тех пор, пока больше не
останется соответствий шаблону.

==============================================================================
*12.8*  Поиск строк, где используется слово

Если используется UNIX-подобная система, то можете задействовать комбинацию с
редактором Vim и программой grep для редактирования всех файлов, содержащих
заданное слово. Это чрезвычайно удобно, если ведётся работа над исходным кодом
программы и необходимо просмотреть или отредактировать все файлы, содержащие
какую-то определённую переменную. Предположим, что необходимо отредактировать
все файлы с кодом на языке Си, содержащие слово «frame_counter». Для этого
используйте такую команду

>
	vim `grep -l frame_counter *.c`
<

Разберём приведённый выше пример. По команде grep выполняется поиск заданного
слова в серии файлов. Поскольку указан ключ -l, то командой будет выведен лишь
список файлов, в которых встречается указанное слово, без вывода строк,
содержащих искомое слово «frame_counter». Вместо слова можно было бы
использовать любое регулярное выражение (обратите внимание, что регулярные
выражения в команде grep и в редакторе Vim не всегда совпадают по синтаксису).
Вся команда целиком заключается в символы ` (обратная одинарная кавычка). Это
указывает командной оболочке в UNIX-подобных системах, что нужно выполнить
команду и подставить результат её выполнения в командную строку. В итоге,
результат выполнения команды grep, — перечень файлов, — передаётся в качестве
списка аргументов редактору Vim. Для перемещения между файлами можно
использовать команды ":next", ":first" и т. п.


ПОИСК ВСЕХ СТРОК

Указанной выше командой будут найдены лишь файлы, в которых встречается
заданное слово. Но теперь требуется найти это слово в самих файлах. В
редакторе Vim есть встроенная команда, которая позволяет искать в нескольких
файлах заданную строку. Например, если требуется найти во всех исходных
текстах программы на языке Си строку «error_string», введите команду

>
	:grep error_string *.c
<

В результате выполнения этой команды в редакторе Vim будет открыт первый файл,
где встречается «error_string» и установлена каретка на первой строке с
искомым словом. Чтобы перейти к следующей строке, независимо от того, в каком
файле она находится, используйте команду ":cnext". Чтобы перейти к предыдущему
совпадению предусмотрена команда ":cprev". Чтобы просмотреть список всех
найденных совпадений, используйте команду ":clist". Команда ":grep" в
редакторе Vim, использует внешнюю программу "grep" (в UNIX-подобных системах)
или "findstr" (в системе Windows). Название используемой программы можно
изменить, настроив параметр 'grepprg'.

==============================================================================

Следующая глава: |usr_20.txt|  Быстрый набор в командной строке
Авторские права: см. |авторские_права_на_документацию|
Перевод на русский язык: © Restorer, 2017—2022, restorer@mail2k.ru

vim:tw=78:ts=8:noet:ft=help:norl:
