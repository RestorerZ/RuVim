*usr_40.txt*	       для Vim version 9.0	      редакция от 02 сен 2020


		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

			    Составные команды


Программа Vim это редактор с расширяемой функциональностью. Так, например,
можно из последовательности часто используемых команд создать новую команду,
также можно назначить существующей команде иное действие. А такой механизм как
«автокоманды» позволяет автоматизировать исполнение команд при возникновении
определённых условий.

|40.1|	Клавиатурные команды
|40.2|	Создание команд режима командной строки
|40.3|	Автокоманды

 Следующая глава: |usr_41.txt|  Встроенный язык программирования
Предыдущая глава: |usr_32.txt|  Древовидная структура хранения изменений
      Содержание: |usr_toc.txt|

==============================================================================
*40.1*	Клавиатурные команды

Простые примеры использования клавиатурных команд приводились в параграфе
|05.3|. Смысл составных команд заключается в том, что нажатие
последовательности одних клавиш клавиатуры трактуются как нажатие других
клавиш клавиатуры. Несмотря на такую простоту, это, между тем, довольно мощный
механизм.
    Простейшая форма клавиатурной команды заключается в сопоставлении одной
клавиши некоторой последовательности других клавиш. Так как функциональные
клавиши, за исключением клавиши <F1>, не имеют каких-либо предустановленных
назначений в программе Vim, то их вполне можно использовать в клавиатурных
командах. Вот пример такой команды:

>
	:map <F2> GoДата: <Esc>:read !date<CR>kJ
<

На примере этой команды разберём, как могут быть задействованы сразу три
режима работы редактора Vim в одной составной команде. При исполнении этой
команды после нажатия клавиши <F2> происходит следующее: по команде `G`
каретка будет перемещена на последнюю строку файла, далее открывается новая
строка по команде `o`, с переключением редактора в режим вставки. После этого
вставляется текста «Дата: » и имитируется нажатие клавиши <ESC> для
переключения обратно в режим команд.
    Обратите внимание на символы <> при указании специальной клавиши <ESC>.
Это называется соглашением по использованию угловых скобок. Набор символов по
этому соглашению происходит буквально, без нажатия каких‐либо специальных
клавиш. Это позволяет сделать клавиатурные команды более наглядными, к тому же
запись этой команды можно без всяких опасений копировать и вставлять в текст.
    При дальнейшей обработке этой последовательности команд будет считан
символ «:», который в данном случае будет обработан как команда для
переключения редактора Vim в режим командной строки. По команде ":read !date"
выполняется считывание вывода внешней команды «date» и вставка полученного
результата после текущей строки. Для исполнения команды ":read" требуется
нажатие клавиши <ENTER> и здесь это задаётся через указание <CR>.
    В процессе исполнения этой команды, текст в буфере будет выглядеть
примерно так:

    Дата: ~
    пятница, 15 ноября 2021 г. 23:51:34 (MSK) ~

Затем при последовательном исполнении команд `k` и `J` каретка будет
перемещена вверх на одну строку и выполнено объединение этой строки и
нижележащей в одну общую строку. О том, какие клавиши лучше использовать в
клавиатурных командах, читайте в параграфе |map-which-keys|.


КЛАВИАТУРНЫЕ КОМАНДЫ И РЕЖИМЫ РЕДАКТОРА

По команде ":map" будут определены клавиатурные команды, действующие в режиме
команд. И, конечно же, существует возможность задать клавиатурные команды,
действующие и в других режимах работы редактора Vim. Так, по команде ":imap"
задаются клавиатурные команды для режима вставки. Например, в приведённом ниже
примере показана возможность вставлять текущую дату при наборе текста.

>
	:imap <F2> <CR>Дата: <Esc>:read !date<CR>kJ
<

Как видите, это очень похоже на созданную раннее клавиатурную команду для
клавиши <F2>, всё различие только в начальной команде. При этом клавиатурная
команда для <F2> в режиме команд остаётся работоспособной, поэтому можно
использовать одну и ту же клавишу для вызова в зависимости от действующего
режима различных команд.
    Обратите внимание, что после исполнения этой клавиатурной команды, режим
работы редактора будет переключён в режим команд, не смотря на то, что команда
была отдана в режиме вставки. Если требуется, чтобы работа редактора была
продолжена в режиме вставки, то добавьте завершающую команду `a` в определение
этой клавиатурной команды.

Ниже приведён перечень команд, используемых для назначения клавиатурных команд
действующих в указанных режимах работы редактора Vim:

	:map		в режиме команд, визуальном и режиме ожидания команды;
	:vmap		в визуальном режиме;
	:nmap		в режиме команд;
	:omap		в режиме ожидания команды;
	:map!		в режиме вставки и режиме командной строки;
	:imap		в режиме вставки;
	:cmap		в режиме командной строки.

Режим ожидания команды это режим, в котором находится программа, после того
как на клавиатуре была набрана команда‐оператор, такая как `d` или `y`.
Называется он так потому, что редактор ожидает указание текстового объекта или
команды перемещения для определения области текста, к которой должен быть
применён оператор. Иными словами, при наборе команды `dw`, клавиша «w» будет
нажата уже в режиме ожидания команды.

Предположим, что необходимо, чтобы при нажатии клавиши <F7> в команде "d<F7>"
происходило удаление программного блока написанного на языке программирования
Си (то есть текст, заключённый внутри фигурных скобок «{» и «}») или по
команде "y<F7>" выполнялось копирование программного кода в безымянный
регистр. Для этого требуется назначить выборку текущего программного блока на
клавишу <F7> и сделать это можно следующей командой

>
	:omap <F7> a{
<

По этой команде будет выполнена «привязка» команды выделения текстового
объекта "a{" к клавише <F7>, действующая только в режиме ожидания команды.
Такая клавиатурная команда будет полезна в тех случая, когда набор символа «{»
бывает сложен на клавиатуре.


ПЕРЕЧЕНЬ КЛАВИАТУРНЫХ КОМАНД

Чтобы посмотреть текущих клавиатурные команды, воспользуйтесь командой ":map"
без указания любых аргументов. Либо команду назначения клавиатурной команды в
определённом режиме, для просмотра клавиатурных команд действующих в этом
самом режиме. Результат исполнения этих команд выглядит примерно так:

       _g		:call MyGrep(1)<CR> ~
    v  <F2>		:s/^/> /<CR>:noh<CR>`` ~
    n  <F2>		:.,$s/^/> /<CR>:noh<CR>`` ~
       <xHome>		<Home>
       <xEnd>		<End>

В первом столбце указывается режим, в котором действует та или иная
клавиатурная команда. Буквой «n» обозначается режим команд, буквой «i» — режим
вставки и т. п. Никак не обозначаются клавиатурные команды, назначенные по
команде ":map", они действуют и в режиме команд, и в режиме вставки.
    Одно из полезных применений подобного перечня клавиатурных команд состоит
в том, что с его помощью легко проверить правильность распознавания
специальных клавиш записанных в угловых скобках <> (при условии, что терминал
поддерживает цвета). Если слово «<Esc>» выделено в перечне другим цветом, то
это означает, что в клавиатурной команде используется специальная клавиша.
Если же цветовое выделение отсутствует, то такая запись будет распознаваться,
как пять отдельных символов. 


ПОДСТАНОВКА ОДНИХ СОСТАВНЫХ КОМАНД В ДРУГИЕ СОСТАВНЫЕ КОМАНДЫ

Результат клавиатурной команды проверяется на предмет содержания других
клавиатурных команд. Например, ранее приведённые примеры клавиатурных команд
для клавиши <F2> можно сократить следующим способом:

>
	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oДата: <Esc>:read !date<CR>kJ
<

В режиме команд по клавише <F2> выполняется переход к последней строке и затем
выполняются те действия, которые выполнялись бы при нажатии клавиши <F3>. В
режиме вставки по клавише <F2> выполняется завершение режима вставки, как по
нажатию клавиши <ESC>, и затем также выполняются действия как при нажатии
клавиши <F3>. Для клавиши <F3> назначена последовательность команд, по которой
делается вся основная работа.

В случае если не требуется регулярное использование Ex-режима редактора Vim,
то можно задействовать команду `Q` для форматирования текста, как это было в
прежних версиях программы. Для этого подойдёт такая клавиатурная команда:

>
	:map Q gq
<

Для тех редких случаев, когда всё же потребуется переключение в Ex-режим,
назначим клавиатурную команду на клавиши «gQ» для команды `Q`

>
	:map gQ Q
<

Но в этом случае нас поджидает маленькая неприятность. При вводе клавиатурной
команды `gQ` должно, по идее, выполнятся переключение в Ex-режим так, как это
происходит при наборе команды `Q`. Однако, на клавишу «Q» была назначена
команда `gq` и значит по клавиатурной команде `gQ` фактически будет
выполняться команда форматирования `gq`, а не переключение в Ex-режим. Чтобы в
данном случае избежать распознавания клавиатурной команды внутри другой
клавиатурной команды, используют команду ":noremap":

>
	:noremap gQ Q
<

Теперь в программе Vim не будет выполняться проверка наличия других команд,
назначенных на клавишу «Q». Подобные команды существуют для всех режимов:

	:noremap	в режиме команд, визуальном и режиме ожидания команды;
	:vnoremap	в визуальном режиме;
	:nnoremap	в режиме команд;
	:onoremap	в режиме ожидания команды;
	:noremap!	в режиме вставки и режиме командной строки;
	:inoremap	в режиме вставки;
	:cnoremap	в режиме командной строки.


ЗАКОЛЬЦОВЫВАНИЕ КЛАВИАТУРНЫХ КОМАНД

Когда клавиатурная команда вызывает саму себя, то она будет выполняться
беспрерывно. Это свойство можно использовать для повтора какого‐либо действия
неограниченное количество раз.
    Как пример, представьте, что есть набор файлов, в которых в первой строке
указан номер версии, и все эти файлы открыты на редактирование по команде "vim
*.txt". Перед внесением правок в первый файл, назначим следующую клавиатурную
команду:

>
	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,
<

Теперь наберём команду ",,". Как и следовало ожидать, начнётся исполнение
последовательности команд, назначенных на эту клавишу. По этим командам будет
выполнена замена символов «5.1» символами «5.2» в первой строке. Далее
выполняется запись текущего файла с переходом к редактированию следующего
файла. Так как перечень команд назначенные на клавиатурную команду ",,"
заканчивается «,,», то в новом файле будет опять вызвана эта же клавиатурная
команда, повторяющая все перечисленные действия.
    И это будет продолжаться до тех пор, пока не возникнет ошибка при
исполнении этой команды. В данном случае ошибка может быть вызвана тем, что в
очередном файле по команде замены не удастся найти совпадения с шаблоном
"5.1". Можно вручную вставить в файл символы «5.1» и вновь набрать команду
",," для продолжения. Исполнение также будет остановлено в том случае, если не
удастся выполнить команду ":wnext", что произойдёт после изменения последнего
файла из набора.
    Если ошибка возникает в какой‐то из команд в назначенной клавиатурной
команде, то оставшаяся часть команд не исполняется. Исполнение клавиатурной
команды может быть прервано по команде CTRL-C (CTRL+BREAK в MS Windows).


УДАЛЕНИЕ КЛАВИАТУРНЫХ КОМАНД

Для удаления существующей клавиатурной команды, используйте команду ":unmap"
или аналогичную команду из приведённого перечня, соответствующую указанному
режиму:

	:unmap		в режиме команд, визуальном и режиме ожидания команды;
	:vunmap		в визуальном режиме;
	:nunmap		в режиме команд;
	:ounmap		в режиме ожидания команды;
	:unmap!		в режиме вставки и режиме командной строки;
	:iunmap		в режиме вставки;
	:cunmap		в режиме командной строки.

Кстати, это можно использовать для назначения клавиатурной команды, которая
действует в режиме команд и в режиме ожидания команды, но не действует в
визуальном режиме. Для этого используем такой трюк, назначим клавиатурную
команду для всех трёх режимов сразу, а затем удалим её для визуального режима:

>
	:map <C-A> /---><CR>
	:vunmap <C-A>
<

Обратите внимание, что здесь используется пять символов для «<C-A>», а не
комбинация клавиш CTRL-A.

Для удаления всех клавиатурных команд за один раз, применяется команда
|:mapclear|. Варианты этой команды для различных режимов можно предугадать по
аналогии с предыдущими примерами. Будьте осторожны при указании этой команды,
так как результат её действия нельзя отменить!


СПЕЦИАЛЬНЫЕ СИМВОЛЫ

После команды назначения клавиатурной команды ":map", в той же строке может
быть указана какая‐то другая команда, а, как известно, для разделения
нескольких команд в одной строке используется символ вертикальной черты «|».
Это означает, что символ «|» не может быть использован в определении
клавиатурной команды, и для указания этого символа применяют слово «Bar» в
угловых скобках. То есть вот так — <Bar>, набрав на клавиатуре пять символов.
Пример.

>
	:map <F8> :write <Bar> !checkin %<CR>
<

Всё сказанное выше относится к команде удаления клавиатурных команд ":unmap" с
одним важным дополнением, следует внимательно следить за наличием пробельных
символов после указания клавиатурной команды. Приведённые ниже команды
абсолютно разные, хотя выглядят почти одинаково

>
	:unmap a | unmap b
	:unmap a| unmap b
<

При исполнении первой из приведённых команд будет предпринята попытка удаления
клавиатурной команды "a ". То есть "a" и следующий после неё пробел.

Чтобы указать в клавиатурной команде пробел, используют слово «Space» в
угловых скобках. Вот так — <Space>, набрав на клавиатуре семь символов.

>
	:map <Space> W
<

Показанная клавиатурная команда позволяет использовать клавишу <ПРОБЕЛ> для
перемещения каретки вперёд на одно СЛОВО.

Непосредственно после определения клавиатурной команды не допускается
указывать комментарий, поскольку символ прямой кавычки «"» будет
распознаваться как часть определения клавиатурной команды. Но возможно указать
такую комбинацию символов — «|"». Это будет распознано как новая, пустая
команда с последующим комментарием. Пример.

>
	:map <Space> W|" Чтобы сдвинуть каретку на одно СЛОВО, нажмите клавишу <ПРОБЕЛ>
<


КЛАВИАТУРНЫЕ КОМАНДЫ И СОКРАЩЕНИЯ

Используемый в редакторе Vim механизм сокращений сильно напоминает
клавиатурные команды, действующие в режиме вставки. Аргументы команд
обрабатываются аналогичным образом, а основное отличие заключается в методах
их исполнения. Сокращение распознаётся при вводе после слова любого символа,
не являющегося его частью. Клавиатурная команда будет распознана сразу после
набора последнего символа, из которых она состоит.
    Другое отличие состоит в том, что символы, используемые в сокращении,
вставляются в текст при наборе. После того как сокращение будет развёрнуто,
ранее введённые символы удаляются, и вместо них подставляется назначенное
сокращению значение. При вводе символов, являющихся клавиатурной командой, в
текст ничего не добавляется до тех пор, пока не будет введён последний символ
клавиатурной команды. Если установлен параметр 'showcmd', то набираемые
символы клавиатурной команды будут отображаться в нижней части окна программы
Vim.
    Исключением являются неоднозначные клавиатурные команды. Предположим, что
определены такие клавиатурные команды:

>
	:imap aa foo
	:imap aaa bar
<

В этом случае, после ввода символов «aa» не может быть распознано однозначно,
какую из клавиатурных команд следует исполнить, поэтому будет ожидание
следующего символа. Если таким символом окажется «a», то будет обработана
вторая клавиатурная команда, и в текст будет вставлено слово «bar». Если таким
символом будет, например, пробел, тогда будет применена первая клавиатурная
команда со вставкой слова «foo» с последующим пробелом после него.


И ЕЩЁ...

Аргумент <script> используется для определения клавиатурных команд,
относящихся к данному командному файлу. См. раздел |:map-<script>|.

Аргумент <buffer> используется для назначения клавиатурных команд, доступных в
определённом буфере. См. раздел |:map-<buffer>|.

Аргумент <unique> используется для того, чтобы команда определения
клавиатурной команды исполнялась только в том случае, если подобная
клавиатурная команда ещё не назначена. В противном случае новое значение
клавиатурной команды заменяет собой раннее присвоенное. См. раздел
|:map-<unique>|.

Чтобы по нажатию клавиши не выполнялось никаких действий, ей назначается
значение <Nop> (пять символов). Следующая команда приведёт к тому, что по
клавише <F7> вообще ничего не будет происходить.

>
	:map <F7> <Nop>| map! <F7> <Nop>
<

После слова <Nop> не должно быть пробела.

==============================================================================
*40.2*	Определение команд режима командной строки

В редактор Vim можно создавать свои собственные команды. И такие команды
исполняются в точности так же, как и остальные команды режима командной
строки.
    Для определения собственных команд используется команда ":command".
Например,

>
	:command DeleteFirst 1delete
<

Если после этого вызвать команду ":DeleteFirst", то будет исполнена команда
":1delete", то есть в реакторе Vim будет выполнено удаление первой строки
файла.

	Примечание.
	Команды, определённые пользователем, должны начинаться с прописной
	буквы. К тому же не допускается использовать для именования команд
	зарезервированные слова ":X", ":Next" и ":Print". В наименовании
	команд запрещён символ подчёркивания! Цифры в наименовании
	использовать можно, но не рекомендуется.

Чтобы просмотреть перечень доступных пользовательских команд, наберите команду

>
	:command
<

Команды, созданные пользователем, могут быть сокращены при наборе в точности
так же, как и встроенные команды программы. Для исполнения пользовательской
команды достаточно набрать ровно столько символов, сколько необходимо для
однозначного распознавания созданной команды. Для подстановки полного
наименования команды можно воспользоваться автодополнением в командной строке.


КОЛИЧЕСТВО АРГУМЕНТОВ

Для команд созданных пользователем, также как и встроенных команд, могут быть
указаны аргументы. А количество передаваемых аргументов должно быть задано
через параметр -nargs. Поскольку для команды ":DeleteFirst" не требуются
аргументы, то её можно было бы определить и так:

>
	:command -nargs=0 DeleteFirst 1delete
<

Однако, поскольку значение 0 принимается по умолчанию, то указывать "-nargs=0"
не обязательно. Возможны следующие значения параметра -nargs:

	-nargs=0	аргументы не используются;
	-nargs=1	один аргумент;
	-nargs=*	любое количество аргументов;
	-nargs=?	0 или 1 аргумент;
	-nargs=+	1 или более аргументов.


ПЕРЕДАЧА АРГУМЕНТОВ

В определении пользовательской команды подстановка аргументов выполняется
через управляющее слово "<args>". Например,

>
	:command -nargs=+ Say :echo "<args>"
<

Теперь, если набрать команду

>
	:Say Привет, мир
<

в редакторе Vim будет выведено сообщение «Привет, мир». Но здесь есть один
нюанс, если в строке аргументов будут присутствовать двойные кавычки, то такая
команда не будет исполнена. Например,

>
	:Say мы скажем "привет"
<

Чтобы можно было передать в команду строку аргументов со спецсимволами, они
должны быть правильно экранированы, и для этого используется управляющее слово
"<q-args>". Пример.

>
	:command -nargs=+ Say :echo <q-args>
<

Теперь при исполнении команды ":Say" будет вызвана соответствующая команда в
таком виде:

>
	:echo "мы скажем \"привет\""
<

Управляющее слово "<f-args>" применяется также как и управляющее слово
"<args>", но формат передаваемых аргументов соответствует аргументам функции.
Например, ввод следующих команд

>
	:command -nargs=* DoIt :call AFunction(<f-args>)
	:DoIt a b c
<

приведёт к исполнению команды

>
	:call AFunction("a", "b", "c")
<


ДИАПАЗОН СТРОК

Некоторые команды принимают в качестве аргумента диапазон строк. Чтобы
определить такую команду, необходимо использовать параметр -range. Возможны
следующие значения этого параметра:

	-range		допускается указание диапазона; по умолчанию — текущая
			строка;
	-range=%	допускается указание диапазона; по умолчанию — весь
			файл;
	-range={число}	допускается указание диапазона как общее количество
			строк, по умолчанию принимается значение {число}.

При указании диапазона строк, в команде используются управляющие слова
"<line1>" и "<line2>" для передачи значений первой и последней строки из
диапазона. Например, следующая команда определяет команду ":SaveIt", которая
записывает указанный диапазон строк в файл «save_file»:

>
	:command -range=% SaveIt :<line1>,<line2>write! save_file
<


ДРУГИЕ ПАРАМЕТРЫ

Ниже перечислены некоторые параметры и соответствующие им управляющие слова
для использования в командах:

	-count={число}		При вызове команды может быть задана числовая
				приставка-аргумент, её значение по умолчанию
				равняется {числу}. Значение приставки
				передаётся в команду с помощью управляющего
				слова "<count>".
	-bang			При вызове команды может быть использован
				модификатор "!". Если параметр установлен, то
				ключевое слово "<bang>" будет
				интерпретироваться как модификатор.
	-register		При вызове команды может быть указан регистр
				(по умолчанию используется безымянный
				регистр). Указанный регистр в команде
				подставляется вместо управляющего слова
				"<reg>" (или "<register>").
	-complete={тип}		Задаёт тип используемой подстановки в
				командной строке. Возможные значений см. в
				разделе |:command-completion|.
	-bar			После набора команды может быть указан символ
				«|» и либо другая команда, либо символ " и
				комментарий.
	-buffer			Действие команды ограничивается только текущим
				буфером.

Кроме того, используется управляющее слово "<lt>" для подстановки вместо
символа «<». Его необходимо применять для экранирования специального значения
упомянутых слов в угловых скобках <>.


ПЕРЕОПРЕДЕЛЕНИЕ И УДАЛЕНИЕ

Для переопределения существующей команды требуется указать модификатор !

>
	:command -nargs=+ Say :echo "<args>"
	:command! -nargs=+ Say :echo <q-args>
<

Для удаления пользовательской команды применяется команда ":delcommand". Эта
команда принимает единственный аргумент, который является наименованием
удаляемой команды. Пример.

>
	:delcommand SaveIt
<

Для удаления всех определённых пользователем команд применяется команда

>
	:comclear
<

Будьте внимательны, эта операция не может быть отменена!

Подробнее о командах, определяемых пользователем, см. в разделе справочника
|user-commands|.

==============================================================================
*40.3*	Автокоманды

Механизм автокоманд — это возможность создания такой команды, которая будет
выполняться автоматически при наступлении определённого события. Например, при
записи или считывании файла, или при изменении содержимого буфера. Используя
эту возможность, можно, например, непосредственно из редактора Vim изменять
содержимое сжатых файлов. Именно это применяется в подключаемом модуле |gzip|.
    Автокоманды — чрезвычайно мощное средство. Используйте его аккуратно, и
оно станет надёжным подспорьем в оптимизации работы, позволяя избежать
повторного набора множества типичных команд. Но при небрежном обращении с
автокомандами, может появиться немало хлопот.

Предположим, что требуется оптимизировать (автоматизировать) такую операцию,
как обновление при сохранении файла отметки времени, и эта метка записывается
в конце файла. Чтобы это сделать, для начала напишем такую функцию:

>
	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction
<

И эта функция должна вызываться для исполнения всякий раз, когда в файле
сохраняются изменения из буфера. Для этого необходимо отдать следующую
команду:

>
	:autocmd BufWritePre *  call DateInsert()
<

Где "BufWritePre" — указание на событие, при наступлении которого выполняется
автокоманда, в данном случае непосредственно перед ("pre", предшествуя)
записью содержимого буфера в файл. Аргумент "*" — это шаблон наименования
файла, к которому применяется данная автокоманда, и в данном случае он
соответствует любому файлу.
    После того, как такая команда автоматического исполнения будет отдана, то
каждый раз, как вводится команда ":write", в программе Vim будет выполнена
проверка каждой автокоманды назначенной для события "BufWritePre" на
соответствие условию применения, и, при положительном результате, выполнены
указанные действия перед исполнением команды ":write".
    Общий синтаксис команды ":autocmd" следующий:

>
	:autocmd [группа] {события} {шаблон_файла} [++nested] {команда}
<

    Необязательный аргумент [группа] используется для облегчения управления
такими командами (подробнее об этом далее).
    Через аргумент {события} указываются события, наступление которых вызывает
исполнение команды, наименования событий разделяются запятой.
    Аргумент {шаблон_файла} служит для указания наименования файлов, обычно
задаваемых в виде маски. Например, применение маски «*.txt» позволяет
выполнять автокоманду для всех файлов, которые имеют расширение «.txt».
    Необязательный аргумент [++nested] (вложенные) позволяет обрабатывать
автокоманды для событий, порождаемых данной автокомандой (см. далее).
    И, наконец, собственно {команда}, которую требуется исполнить.


СОБЫТИЯ

Одним из самых часто используемых событием является событие с наименование
"BufReadPost". Оно происходит после того, когда началось редактирование нового
файла. Возникновение этого события часто используют для выполнения
автоматической установки необходимых параметров для редактируемого файла.
Например, известно, что файлы «*.gsm» содержат исходный код программы на языке
ассемблера GNU. Чтобы использовать для этих файлов корректные правила
подсветки синтаксиса, напишем следующую автокоманду:

>
	:autocmd BufReadPost *.gsm  set filetype=asm
<

Когда программой Vim будет распознан тип файла, то для редактируемого файла
будет выполнена автоматическая установка соответствующего значения параметра
'filetype'. Момент распознавания типа файла, в свою очередь, порождает событие
с наименование «Filetype». Возникновение данного события можно использовать
для выполнения определённых действий при редактировании распознанного типа
файла. Например, для загрузки перечня сокращений, используемых в текстовых
файлах:

>
	:autocmd Filetype text  source ~/.vim/abbrevs.vim
<

При создании нового файла в программе Vim, можно дать указание на вставку в
буфер подготовленного шаблона‐заготовки

>
	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c
<

Полный список событий смотрите в справочнике |autocmd-events|.


ШАБЛОНЫ НАИМЕНОВАНИЙ ФАЙЛОВ

Аргумент {шаблон_файла} может представлять собой разделённый запятыми перечень
шаблонных наименований. Например, шаблон "*.c,*.h" соответствует всем файлам,
наименования которых заканчиваются символами «.c» и «.h».
    Здесь могут применяться обычные подстановочные символы. Вот наиболее часто
употребляемые из них:

	*		соответствует любому символу любое количество раз
	?		соответствует любому символу один раз
	[abc]		соответствует символу «a», «b» или «c»
	.		соответствует символу точки
	a{b,c}		соответствует символам «ab» и «ac»

Если в шаблоне используется символ наклонной черты (/), то в программе Vim
будет также выполняться сравнение указанных каталогов. Без указания наклонной
черты поиск выполняется только по наименованию файла. Например, шаблон "*.txt"
соответствует "/home/biep/readme.txt". Этот файл также будет найден по шаблону
"/home/biep/*", но не найден по шаблону "home/foo/*.txt".
    При указании наклонной черты в шаблоне, программой Vim будет выполняться
поиск как по абсолютным маршрутам к файлу (например «/home/biep/readme.txt»),
так и по относительным («biep/readme.txt»).

	Примечание.
	При работе в системе, которая использует в качестве разделителя
	каталога в маршрутах к файлу обратную наклонную черту, например в MS
	Windows, все равно необходимо использовать в определении автокоманды
	символ прямой наклонной черты. Это не только позволяет упростить
	написание шаблона, в котором обратная наклонная черта имеет особое
	значение, но и позволяет пользоваться такими автокомандами также и на
	других системах.


УДАЛЕНИЕ АВТОКОМАНДЫ

Для удаления автокоманды используется та же команда, что и для определения, но
с указанием модификатора ! и с пустым значением аргумента {команда}. Пример.

>
	:autocmd! FileWritePre *
<

При исполнении этой команды будут удалены все автокоманды по событию
«FileWritePre», которые используют шаблон "*" в качестве указания наименования
файла.


ПЕРЕЧЕНЬ АВТОКОМАНД

Чтобы посмотреть созданные к текущему моменту автокоманды, используйте команду

>
	:autocmd
<

Перечень может оказаться довольно длинным, особенно если задействовано
определение типа файла. Чтобы посмотреть только какие‐то определённые
автокоманды, используйте в качестве аргумента этой команды или наименование
группы, или наименование события, или шаблон, либо любое сочетание из
указанного. Например, чтобы посмотреть перечень всех автокоманд по событию
«BufNewFile», наберите команду

>
	:autocmd BufNewFile
<

А по этой команде будет показан перечень всех автокоманд с заданным шаблоном
"*.c" в качестве наименования файла

>
	:autocmd * *.c
<

Использование символа «*» вместо наименования события позволяет просмотреть
автокоманды для всех событий.
    Чтобы посмотреть перечень автокоманд в группе cprograms, введите команду

>
	:autocmd cprograms
<


ГРУППЫ

Аргумент {группа} в определении автокоманды используется для группирования
схожих автокоманд. Это может быть использовано, например, для удаления всех
автокоманд, которые принадлежат одной группе.
    При создании нескольких автокоманд, которые принадлежат к одной группе,
используйте команду ":augroup". В качестве примера, давайте создадим
автокоманды, которые будут применяться для текстов программ на языке Си:

>
	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END
<

Это эквивалентно таким командам

>
	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3
<

Удаления всех автокоманд группы «cprograms», используйте

>
	:autocmd! cprograms
<


ВЛОЖЕННЫЕ АВТОКОМАНДЫ

Обычно команды, которые исполняются в результате применения какой-либо
автокоманды, не вызывают возникновение новых событий. Если выполняется
считывание файла по событию «FileChangedShell», то это не будет приводить к
обработке других автокоманд, которые, например, настраивали бы для этого файла
правила синтаксиса. Чтобы выполнялась обработка порождаемых событий, то
используйте необязательный аргумент "++nested":

>
	:autocmd FileChangedShell * ++nested  edit
<


ИСПОЛНЕНИЕ АВТОКОМАНД

Возможен вызов автоматической команды через симуляцию возникновение события.
Это бывает полезно в том случае, когда одна автокоманда вызывает другую
автокоманду. Например,

>
	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " .. expand("<afile>:r")
<

В этом примере задана автоматическая команда, которая будет обработана после
того, как будет открыт на редактирование файл с расширением «.new». В
исполнительной части этой автокоманды содержится команда ":execute", которая
вычисляет выражение, переданное ей как аргумент, и передаёт на исполнение
получившуюся в результате команду. При открытии, например, файла
«tryout.c.new», будет исполнена команда

>
	:doautocmd BufReadPost tryout.c
<

Функция expand() принимает аргумент "<afile>", значением которого является
шаблон наименования файла заданного в автокоманде, разворачивает его в
полноценное наименование с последующим отсечением его расширения, что
предписано через модификатор ":r". 

Заданная команда ":doautocmd" будет применяться только для текущего буфера. А
вот команда ":doautoall" работает так же, как и команда ":doautocmd", за
исключением того, что она применяется ко всем буферам.


ПРИМЕНЕНИЕ КОМАНД РЕЖИМА КОМАНД

Исполняемые команды, указываемые при составлении автокоманды, являются
командами командной строки. Если требуется, чтобы при обработке автокоманды
исполнялись команды режима команд, то используйте для этого команду ":normal".

>
	:autocmd BufReadPost *.log normal G
<

В данном примере показана возможность перемещения каретки в конец текста по
команде `G` при открытии файла с расширением «.log».
    Использование команды ":normal" требует немного ловкости. Прежде всего,
убедитесь, что аргумент этой команды является законченной командой режима
команд со всеми требуемыми аргументами. Если для переключения в режим вставки
используется команда `i`, то следите за тем, чтобы не забыть указать команду
<Esc> для выхода из режима вставки. Если используется команда `/` для
выполнения поиска по шаблону, то не забудьте также указать команду <CR>, чтобы
команда поиска была выполнена.
    В команде ":normal" весь текст, который следует после неё, расценивается
как команда, которую требуется исполнить. Поэтому с этой командой не может
использоваться символ «|» с указанием после него последующей новой командой.
Чтобы обойти это ограничение, укажите команду ":normal" как аргумент команды
":execute". Это также позволяет удобно передавать команде непечатаемые символы.
Пример.

>
	:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
		\ 1read !date
<

В этом примере также демонстрируется использование обратной наклонной черты
для разбивки длинной команды на несколько строк. Этот приём можно использовать
в командных файлах программы Vim, но не в самой командной строке программы.

Если требуется, чтобы при обработке автокоманды выполнялся ряд сложных
действий, включающих перемещение по тексту с возвратом в исходную позицию
каретки, то, возможно, подойдёт восстановление представления файла. См. в
качестве примера параграф |restore-position|.


ПРОПУСК СОБЫТИЙ

Иногда возникают ситуации, когда требуется, чтобы не выполнялась обработка
автокоманд при наступлении определённых событий. Для этого необходимо в
параметре 'eventignore' указать перечень событий, которые будут
игнорироваться. Например, по следующей команде задаются настройки
игнорирования событий переключения фокуса ввода на окно и сброс фокуса с окна
с точки зрения отработки автокоманд

>
	:set eventignore=WinEnter,WinLeave
<

Чтобы игнорировались все события, используйте команду

>
	:set eventignore=all
<

Для восстановления стандартного поведения, удалите все значения в параметре
'eventignore'

>
	:set eventignore=
<

==============================================================================

Следующая глава: |usr_41.txt|  Встроенный язык программирования
Авторские права: см. |manual-copyright|  
© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

vim:tw=78:ts=8:ft=help:norl:
