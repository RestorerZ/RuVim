*usr_10.txt*	       для Vim version 9.0	      редакция от 22 ноя 2019

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

		       Расширенные приёмы правки текста


В главе 4 рассказывалось об основных приёмах правки текстов. В этой главе
будет объяснено, как работать с повторяющимися изменения или изменениями
затрагивающие большие объёмы текста, показаны приёмы, полезные при работе с
визуальными блоками, и использование внешних программ для выполнения сложных
операций.

|10.1|  Запись и повторное выполнение команд
|10.2|  Замена текста
|10.3|  Диапазон действия команд
|10.4|  Команда global
|10.5|  Режим визуального блока
|10.6|  Чтение и запись фрагментов файла
|10.7|  Форматирование текста
|10.8|  Изменение регистра символов
|10.9|  Использование внешних программ

 Следующая глава: |usr_11.txt|  Восстановление после аварийных ситуаций
Предыдущая глава: |usr_09.txt|  Графический  интерфейс программы
      Содержание: |usr_toc.txt|

==============================================================================
*10.1*  Запись и повторное выполнение команд

Как уже говорилось ранее, по команде `.` (точка) повторно выполняется
предыдущая команда для изменения текста. Но что делать, если необходимо
повторно выполнить нечто более сложное, чем единичная команда редактирования?
Для этого существует процедура записи команд, которая выполняется в три
простых этапа:

1. По команде "q{регистр}" начать запись нажимаемых клавиш в {регистр}.
   Название регистра должно быть задано буквами в диапазоне от a до z.
2. Ввести требуемые команды.
3. Завершить запись, повторно нажав клавишу "q" (без дополнительных символов).

Теперь можно воспроизвести записанный макрос по команде "@{регистр}".

Давайте попрактикуемся в использовании данной возможности. Предположим, в
тексте есть список файлов, который выглядит как:

	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~

и требуется получить следующее:

	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~

Прежде всего, установите каретку на первом символе первой строки. Затем
введите следующие команды:

	qa			начало записи макроса в регистр "a;
	^			перемещение каретки в начало строки;
	i#include "<ESC>	вставка строки #include " в начало строки;
	$			перемещение каретки в конец строки;
	a"<ESC>			добавление символа двойной кавычки (")
				в конце строки;
	j			переход к следующей строке;
	q			окончание записи макроса.

Выполнив эти действия лишь один раз, можно повторить весь процесс для
остальных строк простым вводом команды "@a" три раза.
    Команда "@a" может предваряться числом-приставкой, которое задаёт
количество повторений выполнения макроса. В данном случае можно просто набрать

>
	3@a
<


ПЕРЕМЕЩЕНИЕ И ВЫПОЛНЕНИЕ

В случае если строки, к которым необходимо применить записанную
макропоследовательность команд, расположены в разных частях документа, то
переместите каретку к требуемой строке и введите команду "@a". После первого
исполнения макроса, записанного в регистр "a, его повторный вызов
осуществляется командой `@@`, что несколько быстрее при наборе. В случае если
после применения макрокоманды из регистра "a был применён макрос, записанный в
регистр "b командой "@b", то по следующей команде `@@` будет вызвана
макрокоманда из регистра "b.
    Сравнивая метод воспроизведения команд записанных в регистр, с методом
повторного выполнения посредством команды `.`, обнаруживается несколько
различий. Во-первых, по команде `.` может быть повторена только одна команда
правки, а посредством команд вроде "@a" могут быть выполнены целые серии
изменений, включая перемещение каретки, как это видно из приведённого выше
примера. Во-вторых, по команде `.` выполняется только одно последнее
сохранённое изменение. При использовании же регистра можно производить любые
изменения текста, не опасаясь, что содержащиеся в регистре команды будут
изменены. Наконец, в нашем распоряжении целых 26 регистров, что позволяет
записать для последующего воспроизведения до 26 различных макрокоманд.


ИСПОЛЬЗОВАНИЕ РЕГИСТРОВ

Регистры, которые используются для записи макроса, — те же, что и для команд
копирования и удаления. Это позволяет использовать запись вместе с другими
командами, которые работают с регистрами. Предположим, в регистр "n было
записано несколько команд. При исполнении команд из этого регистра по команде
"@n" вдруг обнаруживается, что допущена ошибка в записанных командах. Можно,
конечно, записать макрос с самого начала, но кто даст гарантию, что не будет
совершено новых ошибок? Вместо этого, можно воспользоваться вот каким приёмом:

	G		    переместите каретку в конец файла;
	o<ESC>		    создайте пустую строку;
	"np		    вставьте содержимое регистра "n в эту строку
			    (набранные команды будут отображаться как текст);
	{редактирование}    измените команды, в которых была допущена ошибка
			    так же, как редактируете обычный текст;
	0		    переместите каретку в начало строки;
	"ny$		    скопируйте исправленную строку в регистр "n;
	dd		    удалите ненужную строку.

Теперь можно выполнять макрос с исправленными командами с помощью "@n". (Если
записанные в макрос команды содержат перевод строк, то учтите этот факт в
предыдущем примере, когда будете копировать текст макроса в регистр, чтобы
скопировать все строки).


ДОБАВЛЕНИЕ В РЕГИСТР

При записи макропоследовательностей команд в регистр с наименованием, заданным
строчной латинской буквой, предыдущее содержание указанного регистра будет
перезаписываться новыми командами. Для того, чтобы что‐то добавить к
содержимому в регистре, используйте прописную латинскую букву в названии этого
регистра. Представьте, что в регистр "c записан макрос для изменения слова. Он
работает прекрасно, но теперь требуется добавить поиск следующего слова,
которое необходимо изменить. Этого можно добиться командой

>
	qC/слово<Enter>q
<

При указании команды "qC" будет выполнено дописывание команды в конец макроса,
который уже содержится в регистре "c. Таким образом, запись в регистр,
наименование которого задаётся прописной латинской буквой, означает добавление
в регистр, наименование которого обозначается той же самой буквой, но
строчной.

Этот приём работает как с командами для записи макропоследовательностей, так и
с командами для копирования и удаления. Например, необходимо собрать
последовательность строк в регистр "a. Скопируйте первую строку при помощи
команды

>
	"aY
<

Теперь перейдите к следующей требуемой строке и наберите

>
	"AY
<

Эту команду можно повторить для всех строк, которые необходимо копировать.
Регистр "a теперь содержит все необходимые строки в том порядке, в котором они
были скопированы.

==============================================================================
*10.2*  Замена текста
						*find-replace*  *поиск_и_замена*

По команде ":substitute" (замещение) будет выполняться замена текста в
указанном диапазоне строк. В общем виде синтаксис этой команды следующий:

>
	:[диапазон]substitute/что/чем/[флаги]
<

При исполнении этой команды будет выполняться замена 'что' тем, что указанно
как 'чем' во всех строках, на которые указывает [диапазон]. Например, можно
заменить «хакер» словом «ламер» такой вот простой командой

>
	:%substitute/хакер/ламер/
<

	Примечание.
	Название команды ":substitute" почти никогда не вводится полностью.
	Чаще всего используется сокращённый вариант ":s". Далее мы также будем
	пользоваться сокращённой записью.

Значение диапазона, заданное как "%", указывает на все строки текста. Без
указания диапазона команда ":s" применяется только к текущей строке. Мы
расскажем о диапазонах подробнее в следующем параграфе |10.3|.

По умолчанию, ":substitute" заменяет только первое найденное слово «что» в
строке. Например, по указанной выше команде будет сделана следующая замена:

	Неожиданно, хакер Крутой заметил, что хакер Пупкин вошёл в сеть. ~

на

	Неожиданно, ламер Крутой заметил, что хакер Пупкин вошёл в сеть. ~

Чтобы заменить все совпадения в строке, необходимо добавить к команде флаг 'g'
(global, повсюду). По команде

>
	:%s/хакер/ламер/g
<

будет так изменена первоначальная строка

	Неожиданно, ламер Крутой заметил, что ламер Пупкин вошёл в сеть. ~

Другие флаги, которые можно использовать с командой ":s", — флаг 'p' (print,
печать) для вывода последней строки, которая была изменена командой, флаг 'c'
(confirm, подтверждение) для запроса подтверждения перед выполнением замены.
Введите следующую команду:

>
	:%s/хакер/ламер/c
<

Будет найдено первое совподение в тексте со словом «хакер» и выведен запрос, с
указанием заменяющего его текста. Примерно такой:

>
	заменить словом ламер ? (y; n; a; q; l; CTRL+E; CTRL+Y)
<

В ответ на данный запрос необходимо указать один из предложенных вариантов:

	y	    да (yes) — заменить;
	n	    нет (no) — пропустить;
	a	    все (all) — сделать эту замену и все последующие без
		    дальнейших запросов;
	q	    выйти (quit) — не выполнять ни каких замен;
	l	    последний раз (last) — сделать эту замену и завершить;
	CTRL-E	    прокрутить текст на одну строку вверх;
	CTRL-Y	    прокрутить текст на одну строку вниз.

В команде замены аргумент 'что' является на самом деле шаблоном, таким же, как
и тот, который используется в командах поиска. Например, при выполнении
следующей команды производится замена слова «хакер» только в том случае, если
оно появляется в начале строки

>
	:s/^хакер/ламер/
<

Если аргументы 'что' или 'чем' команды замены содержат наклонную черту, то
перед ней необходимо добавить обратную наклонную черту, т. е. экранировать.
Более простой способ заключается в использовании другого символа в качестве
разделителя, например «+» (знак плюс)

>
	:s+один/два+один или два+
<

==============================================================================
*10.3*  Диапазон действия команд

Команда ":substitute", как и многие другие команды начинающиеся символом :
(двоеточие), могут работать с диапазонами строк. Диапазон в самой простой
форме выглядит так: {номер},{номер}. Например, по команде

>
	:1,5s/что/чем/g
<

будет выполнена замена на строках с номерами от 1 до 5 включительно. Диапазон
всегда указывается перед командой.

Одиночное число указывает на строку с определённым номером

>
	:54s/Хакер/Ламер/
<

Если не задан диапазон, то некоторые команды применяются ко всему файлу
целиком. Для таких команд можно использовать адрес ".", который указывает на
текущую строку. К таким командам относится, например, команда ":write". Без
указания диапазона будет выполнена запись всех строк файла. Напротив, по
команде

>
	:.write другой_файл
<

будет выполнена запись в «другой_файл» только текущей строки. Первая строка
всегда имеет номер 1, а последнюю строку можно обозначить символом «$».
Например, команда для замены текста от текущей позиции каретки до конца файла

>
	:.,$s/да/нет/
<

Диапазон "%", о котором мы говорили выше, на самом деле просто сокращённая
форма для записи "1,$" — «от первой до последней строки в файле».


ИСПОЛЬЗОВАНИЕ ШАБЛОНОВ ПРИ УКАЗАНИИ ДИАПАЗОНА

Предположим, что редактируется книга и в одной из глав необходимо заменить все
слова «хакер» словом «гик», но только в этой главе. Книга разбита на главы,
каждая из которых начинается со слова «Глава» расположенного в первой колонке
текста. Тогда можно выполнить такую команду:

>
	:?^Глава?,/^Глава/s=хакер=гик=g
<

Обратите внимание, что шаблон поиска используется дважды. По первому шаблону
"?^Глава?" ищется строка, начинающаяся со слова «Глава» выше текущей позиции,
соответствующей заданному шаблону. Таким образом, диапазон ?шаблон?
используется для поиска в обратном направлении. Аналогично, шаблон "/^Глава/"
используется для поиска строки начинающейся со слова «Глава» вперёд по тексту
для поиска начала следующей главы. Чтобы избежать путаницы с наклонной чертой,
в команде замены в качестве разделителя используется символ «=», но можно было
бы использовать и наклонную черту или другой символ.


СЛОЖЕНИЕ И ВЫЧИТАНИЕ

В указанной выше команде есть небольшая ошибка — если в заголовке следующей
главы есть слово «хакер», то оно будет также заменено. Но что если это не
совсем то, что нужно? В этом случае необходимо использовать смещение. Для
работы со строкой расположенной выше строки соответствующей заданному шаблону,
используют следующий приём

>
	/Глава/-1
<

Вместо единицы можно использовать любое другое число. Для адресации ко второй
строке расположенной ниже строки соответствующей шаблону, используют следующий
приём

>
	/Глава/+2
<

Смещения можно использовать и с другими элементами диапазона. Например, запись

>
	:.+3,$-5
<

указывает на то, что в диапазон будут включены строки, начиная с третьей
строки от текущей и заканчивая пятой строкой от последней строки в файле.


ИСПОЛЬЗОВАНИЕ ЗАКЛАДОК

Вместо вычисления номеров строк в тех или иных позициях для указания их в
диапазоне, можно применять закладки. Установите закладку в тексте, как об этом
рассказано в главе 3. Например, используйте закладку "mt" для верхней части
области диапазона, и "mb" для отметки нижней части. Теперь можно использовать
закладки для указания диапазона строк (в диапазон включаются и маркированные
строки) вот так:

>
	:'t,'b
<


ВИЗУАЛЬНЫЙ РЕЖИМ И ДИАПАЗОНЫ

Если в визуальном режиме выделить текст и набрать ":" (двоеточие), чтобы
начать ввод команды, то в командной строке будет отображаться следующее:

>
	:'<,'>
<

Теперь можно набрать команду и она будет применена ко всему диапазону строк,
который был выбран визуально.

	Примечание.
	При использовании визуального режима для выбора части строки, или при
	использовании CTRL-V для выбора блока текста, команда с двоеточием всё
	равно будет применяться полностью ко всей строке. Такое поведение
	возможно будет изменено в следующих версиях программы Vim.

Обратите внимание, что символы '< и '> это закладки, которые устанавливаются
автоматически в начальной и конечной позициях визуального выделения. Эти
закладки остаются в этих позициях до тех пор, пока не будет выполнено другое
выделение. Поэтому можно использовать команду `'<` для перемещения каретки к
позиции начала визуального выделения. Кроме того, эти закладки можно
использовать совместно с другими способами задания диапазона.

>
	:'>,$
<

Данный диапазон указывает на строки от конечной позиции визуального выделения
и до конца файла.


ЧИСЛО СТРОК

Если точно известно, сколько строк требуется изменить, то можно просто набрать
это число перед вводом символа «:» (двоеточие). Например, наберите "5:", и в
командной строке будет отображаться

>
	:.,.+4
<

Теперь можно набирать команды, которые необходимо использовать. Они будут
работать в диапазоне от "." (текущая строка) до ".+4" (ещё четыре строки
вниз), в итоге, получается, пять строк.

==============================================================================
*10.4*  Команда global

Команда ":global" является одной из самых выдающихся особенностей программы
Vim. С её помощью можно найти текст, соответствующий шаблону, и применить к
этому тексту указанную команду. Синтаксис этой команды следующий:

>
	:[диапазон]global/{шаблон}/{команда}
<

Выглядит очень похоже на команду ":substitute", но вместо замены текста,
совпадающего с шаблоном, другим текстом, выполняется команда {команда}.

	Примечание.
	В команде ":global" в качестве {команды} должна быть использована
	команда, начинающаяся с двоеточия. Нельзя напрямую использовать в ней
	команды режима команд, но обойти это ограничение можно через указание
	команды |:normal|.

Предположим, что требуется поменять «foobar» на «barfoo», но только внутри
комментариев в стиле языка Си++, которые начинаются с символов «//». Для этого
используйте такую команду

>
	:g+//+s/foobar/barfoo/g
<

Разберёмся, что здесь происходит. Команда начинается с ":g", что является
сокращением для ":global", точно так же как ":s" является сокращением для
":substitute". Далее следует шаблон, заключённый в символы «+», поскольку
шаблон, который мы ищем, содержит символ наклонной черты. И в завершении
команда замены, по которой будет заменён «foobar» на «barfoo».
    Диапазоном для команды ":global" по умолчанию является весь файл. Поэтому,
в этом примере не был указан диапазон, что отличает её от команды
":substitute", в которой диапазоном по умолчанию считается текущая строка.
    Приведённая в качестве примера команда не является пределом совершенства,
поскольку она также будет находить появление символов «//» в середине
строки, а замены будут выполнятся перед символами «//».

Как и в случае с ":substitute", можно использовать любой шаблон. Мы изучим
более сложные шаблоны позднее.

==============================================================================
*10.5*  Режим визуального блока

При помощи команды CTRL-V можно выполнить выделение символов в виде
прямоугольного блока и существует несколько команд, выполняющих специальные
операции с такими блоками текста.

Команда `$` при использовании в режиме визуального блока работает несколько
иначе. Если команда `$` была последней командой, использованной для
перемещения каретки, то все строки визуального блока будут выделены вплоть до
конца строки, в том числе и в тех случаях, когда строка, в которой находится
каретка, была более короткой, чем остальные строки. Такое выделение будет
оставаться в силе до тех пор, пока не будут применены команды горизонтального
перемещения каретки, иными словами по команде `j` будет сохраняться такое
поведение, а по команде `h` будет отменено.


ВСТАВКА ТЕКСТА

По команде "I{строка}<Esc>" будет вставлен текст заданный {строка} в каждую
строку слева от границы визуального блока. Начните с выделения визуального
блока при помощи команды CTRL-V, переместите каретку в требуемое положение.
Теперь перейдите в режим вставки по команде `I` (прописная латинская буква I)
и введите текст для вставки. Во время набора текст будет появляться только в
первой строке.
    После нажатия клавиши <ESC> по окончанию ввода, текст будет вставлен во
всех строках, входящих в визуальный блок. Пример.

	include one ~
	include two ~
	include three ~
	include four ~

Переместите каретку к символу «o» в слове «one» и нажмите CTRL-V. Далее,
переместите каретку на три строки вниз командой "3j", чтобы получился
визуальный блок на четыре строки. Теперь наберите

>
	Imain.<Esc>
<

В результате получится следующее:

	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~

Если блок проходит через короткие строки, которые не включаются в блок, то в
этих строках текст не будет вставлен. Например, сделайте выделение визуальным
блоком, включающее слово «очень» в первой и последней строке приведённого ниже
текста, не затрагивая вторую строку:

	Эта строка очень длинная ~
	короткая ~
	Эта строка очень длинная ~

		   ^^^^^ выделенный блок

Теперь наберите команду "Iочень- <Esc>". В результате получится:

	Эта строка очень-очень длинная ~
	короткая ~
	Эта строка очень-очень длинная ~

В короткой строке текст не был вставлен.

Если в тексте, который вставляется, есть символ новой строки, то команда `I`
будет работать, как обычная команда вставки режима команд и повлияет только на
первую строку помеченного блока.

Команда `A` (прописная латинская буква A) работает похожим образом, добавляя
введённый текст в каждой строке, справа от границы выделенного блока. И она
действительно добавляет текст к каждой строке, в том числе и коротким строкам.
Таким образом, есть выбор — добавлять текст к коротким строкам или нет.
    У команды `A` также есть одна особенность. Выделите визуальный блок и
воспользуйтесь командой `$` для расширения блока до границ строк. Теперь по
команде `A` будет добавляться введённый текст к концу каждой строки в блоке, а
не по правой границе выделенного блока.
    Используя пример, приведённый выше, наберите "$A !!!<Esc>" и получится
такой результат:

	Эта строка очень длинная !!! ~
	короткая !!! ~
	Эта строка очень длинная !!! ~

Для достижения такого эффекта требуется использование команды `$` для
перемещения каретки. Выполнение такого же выделения с помощью другой команды
перемещающей каретку в конец самой длинной строки, приведёт к иному
результату.

ИЗМЕНЕНИЕ ТЕКСТА

По команде `c` в режиме визуального блока выполняется удаление блока и
переключение редактора в режим вставки. Набранный текст будет вставлен в
каждой строке, которая содержала выделенный блок.
    Используя всё тот же пример, наберите команду "c_ОЧЕНЬ_<Esc>", и получится
следующий результат:

	Эта строка _ОЧЕНЬ_ длинная~
	короткая ~
	Эта строка _ОЧЕНЬ_ длинная~

Как и в случае с командой `I`, короткая строка не была изменена. Аналогично,
чтобы это работало, в новом тексте нельзя вводить символ перевода строки.

По команде `C` (прописная латинская букв C) выполняется удаление текста от
левого края блока до конца строки и переключение редактора в режим вставки, в
котором можно ввести текст для добавления в конец каждой строки, текст которой
попал в выделение.
    Используйте наш пример ещё раз и наберите команду "Cс новым текстом<Esc>".
Заметьте, что даже если выделить слово «очень» лишь частично, оно всё равно
будет удалено полностью, поскольку с этой командой имеет значение только левый
край выделения:

	Эта строка с новым текстом ~
	короткая ~
	Эта строка с новым текстом ~

Короткая строка, которая не вошла в блок, не будет изменяться.

[Прим. перевод. Чтобы действие указанных в этом подразделе команд
соответствовало описанию, режим виртуальное редактирование должен быть
отключен для визуального блока]

Другие команды, изменяющие символы в блоке:

	~	изменить регистр    (a -> A и A -> a)
	U	в верхний регистр   (a -> A и A -> A)
	u	в нижний регистр    (a -> a и A -> a)


ЗАПОЛНЕНИЕ СИМВОЛОМ

Для заполнения целого блока единичным символом используйте команду `r`.
Попробуйте на нашем примере ввести команду "rx":

	Эта строка xxxxx длинная ~
	короткая ~
	Эта строка xxxxx длинная ~


	Примечание.
	Если требуется вставить символы вне границы строки в блоке, то
	прочитайте об особенности 'virtualedit' в главе 25.


СДВИГ

По команде `>` (знак больше) выполняется сдвиг выбранного текст вправо на
величину ширины сдвига, со вставкой пробельных символов. Начало сдвига
находится по левой границе визуального блока.
    Всё с тем же примером применение команды `>` даст следующий результат:

	Эта строка     очень длинная ~
	короткая ~
	Эта строка     очень длинная ~

Величина сдвига указывается в параметре 'shiftwidth'. Например, для установки
сдвига на 4 символа используйте команду

>
	:set shiftwidth=4
<

По команде `<` (знак меньше) удаляются пробельные символы с левого края блока
в количестве, равном ширине одного сдвига. Эта команда ограничивается
количеством имеющегося текста. Если в тексте содержится пробелов меньше, чем
ширина сдвига, то будет удалено столько пробелов, сколько возможно.


ОБЪЕДИНЕНИЕ СТРОК

По команде `J` (прописная латинская буква J) выполняется объединение всех
выбранных строк в одну, с удалением символа перевода строки. В
действительности при этом происходит замена символа перевода строки, а также
предшествующих ему и последующих пробелов на один пробел. В конце предложения
вставляется два пробела (это можно изменить при помощи параметра
'joinspaces').
    Воспользуемся нашим примером. Результат применения команды `J` будет:

	Эта строка очень длинная короткая Эта строка очень длинная ~

Для применения команды `J` не требуется выделение блока. Она будет работать
точно также с командами `v` (посимвольный) и `V` (построчный) режимами
визуального выделения.

Если требуется, чтобы сохранялись начальные и конечные пробелы в объединяемых
строках, то используйте команду "gJ".

==============================================================================
*10.6*  Чтение и запись фрагментов файла

Предположим, что при написании письма в него необходимо включить содержимое
другого файла. Это можно сделать при помощи команды ":read {название_файла}".
Текст, который содержится в файле, будет помещён под строкой с кареткой.
Допустим, в редакторе уже набран следующий текст:

	Ваня, привет! ~
	Лови diff, который исправляет глюки. ~

	Твой Петя. ~

Подведите каретку ко второй строке и наберите

>
	:read patch
<

Содержимое файла с названием «patch» будет вставлено в текст. Вот результат:

	Ваня, привет! ~
	Лови diff, который исправляет глюки. ~
	2c2 ~
	< for (i = 0; i <= length; ++i) ~
	---~
	>       for (i = 0; i < length; ++i) ~

	Твой Петя. ~

С командой ":read" можно также использовать диапазон, в этом случае содержимое
файла будет вставлено ниже последней строки диапазона. Так, по команде
":$r patch" будет добавлено содержимое файла «patch» в конец редактируемого
файла.
    А что делать, если необходимо поместить содержимое файла перед первой
строкой? Тогда используйте строку с номером ноль. Эта строка, конечно, в
реальности не существует, и при использовании цифры ноль в качестве диапазона,
в большинстве команд будет выдано сообщение об ошибке, но такая команда
разрешена

>
	:0read patch
<

Теперь содержимое файла «patch» вставлено в текст над первой строкой.


ЗАПИСЬ ДИАПАЗОНА СТРОК

Для записи диапазона строк в файл может быть использована команда ":write".
Без указания диапазона будет записан весь файл целиком, но если указать
диапазон, то будут сохранены только указанные строки, например,

>
	:.,$write tempo
<

При выполнении этой команды будут сохранены строки от текущей строки до
последней в файл «tempo». Если файл уже существует, то будет выдано сообщение
об ошибке. Так в редакторе Vim реализована защита от случайной перезаписи
существующего файла. Если вы отдаёте себе отчёт в своих действиях, то допишите
к команде модификатор !, например,

>
	:.,$write! tempo
<

Внимание! Символ «!» (восклицательный знак) должен следовать непосредственно
за командой ":write", без всяких пробелов. В противном случае символ «!»
воспринимается как команда-фильтр, которая объясняется далее в этой главе.


ДОБАВЛЕНИЕ В ФАЙЛ

В первом параграфе этой главы мы рассказали о том, как собрать несколько строк
в один регистр. Что‐то подобное можно сделать для сбора строк в файл. Запишите
первую строку при помощи команды

>
	:.write collection
<

Теперь переместите каретку ко второй строке и введите

>
	:.write >>collection
<

Символы «>>» после команды ":write" указывают программе Vim, что не надо
создавать новый файл «collection», а нужно добавить указанную строку в конец
существующего файла. Эту операцию можно повторять требуемое количество раз.

==============================================================================
*10.7*  Форматирование текста

При наборе обычного текста было бы неплохо, если бы длинные строки
автоматически переносились по ширине окна. Чтобы это происходило во время
набора, установите значение параметра 'textwidth' равное требуемой длины
строки. Пример.

>
	:set textwidth=72
<

При разборе примера файла vimrc эта команда была задана для использования со
всеми текстовыми файлами, так что если применяется такой же файл
инициализации, то данный параметр должен быть уже установлен. Чтобы проверить
текущее значение параметра 'textwidth', наберите

>
	:set textwidth
<

Теперь строки будут переноситься автоматически, если их длина превышает 72
символа. Однако, если выполняется вставка текста в середине строки или
удаление текста, то строки всё равно будут слишком длинными или слишком
короткими. В редакторе Vim не применяется автоматическое форматирование текста
на лету.
    Чтобы переформатировать текущий абзац, введите команду

>
	gqap
<

В этой команде вначале вводится оператор `gq`, а затем указание на текстовый
объект "ap", то есть «абзац». Абзац отделяется от следующего абзаца пустой
строкой.

	Примечание.
	Пустая строка, содержащая пробелы, не является разделителем абзацев.
	Будьте внимательны!

Вместо объекта "ap" можно использовать любую команду перемещения или иной
текстовый объект. Если абзацы разделены надлежащим образом, то для
форматирования целого файла используйте команду

>
	gggqG
<

Где по команде `gg` осуществляется переход к первой строке, `gq` это оператор
форматирования, а `G` это команда перемещения к последней строке.

В том случае, если абзацы в тексте не определены чётко, строки можно
форматировать вручную. Переместите каретку к первой строке, которую необходимо
отформатировать, и введите команду "gqj", по которой будет отформатирована
текущая строка и строка, расположенная под ней. Если текст в первой строке был
слишком короткой, то к этому тексту будут добавлен текст из следующей строки.
Если текст был слишком длинный, то текст из этой строки будут перенесён на
следующую строку. Теперь можно использовать команду `.` (точка) для повтора
команды форматирования до тех пор, пока не будет достигнут конец текста,
который требовалось отформатировать.

==============================================================================
*10.8*  Изменение регистра символов

Допустим, в тексте, в котором все заголовки параграфов набраны строчными
буквами, необходимо, чтобы первое слово названия параграфа было набрано
прописными буквами. Это можно сделать используя оператор `gU`. Например,

>
				gUw
<       первый параграф        ---->     ПЕРВЫЙ параграф ~


А оператор `gu` выполняет прямо противоположную операцию,

>
				guw
<       ПЕРВЫЙ параграф        ---->     первый параграф ~


Для изменения регистра букв также можно использовать оператор `g~`. Все эти
операторы могут работать с любыми командами перемещения и текстовыми
объектами, в том числе и в визуальном режиме.
    Чтобы оператор применялся ко всей строке, его обычно повторяют дважды.
Например, оператор удаления `d`, будучи набранный дважды, удаляет всю строку —
`dd`. Аналогично, по `gugu` преобразуется вся строка в нижний регистр
символов. Операторы `gugu` можно сократить до `guu`, `gUgU` до `gUU` и `g~g~`
до `g~~`. Пример.

>
				    g~~
<       Девчонки ЛЮБЯТ Мороженое    ---->   дЕВЧОНКИ любят мОРОЖЕНОЕ ~

==============================================================================
*10.9*  Использование внешних программ

В редактор Vim встроено множество очень полезных и мощных команд, которые
могут делать с текстом почти всё. Тем не менее, существуют программы,
которые делают те или иные операции быстрее или лучше и можно работать с этими
программами напрямую из редактора Vim.
    По команде "!{перемещение}{программа}" берётся блок текста из редактора и
пропускается через внешнюю программу. Другими словами, по этой команде
запускается системная команда, указанная как {программа}, ей передаётся на
вход блок текста, выбранный {перемещением}. Вывод программы заменяет
отмеченный блок текста.
    Если ни когда не приходилось сталкиваться с работой фильтров в
UNIX-подобных системах, то, наверное, это сложно представить, давайте
рассмотрим это на примере. Программа sort сортирует текст в файле. Если
выполнить команду

>
	sort <input.txt >output.txt
<

, то несортированный файл «input.txt» будет отсортирован и записан в файл
«output.txt». (Это работает как в UNIX-подобных системах, так и в MS Windows).
    Теперь сделаем то же самое из редактора Vim. Допустим, необходимо
отсортировать строки файла с первой по пятую. Установите каретку на первую
строку и введите команду

>
	!5G
<

Посредством команды `!` редактор Vim уведомляется, что будет применяться
операция фильтрации. Теперь редактором ожидается команда перемещения, которая
укажет ему, с какой частью текста надо провести эту операцию. Команда "5G" как
раз указывает редактору на перемещение к строке 5, таким образом для редактора
сформировано задание на выполнение фильтрации строк с 1‐ой (текущей) строки по
5‐ую строку.
    В ожидании ввода наименования команды-фильтра, каретка будет перемещена
в командную строку программы Vim в которой в виде символа ! будет показано
приглашение для ввода команды. Теперь можно ввести название команды-фильтра,
в данном случае "sort". Полностью команда будет выглядеть следующим образом

>
	!5Gsort<ENTER>
<

В результате программой sort будет обработано первые пять строк текста. Вывод
программы заменяет то, что было в этих строках до того.

	строка 55			строка 11
	строка 33			строка 22
	строка 11        -->            строка 33
	строка 22			строка 44
	строка 44			строка 55
	последняя строка                последняя строка

По команде "!!" на обработку через программу-фильтр будет передаваться текущая
строка. В UNIX-подобных системах команда "date" выводит текущую дату и время.
Команда "!!date<ENTER>" указывает на замену текущей строки результатом команды
"date", что бывает полезно для добавления отметки о времени в текст файла.


ПОЧЕМУ ПРОГРАММЫ-ФИЛЬТРЫ МОГУТ НЕ РАБОТАТЬ

Запуск командной оболочки, отправка текста программе и получение вывода
требуют, чтобы редактор Vim был соответствующее настроен под работу командной
оболочки на используемой ЭВМ. Если возникают трудности с использованием
программ-фильтров, то проверьте значения следующих параметров:

	'shell'         название программы командной оболочки, используемой
			редактором Vim для запуска внешних программ;
	'shellcmdflag'  аргумент, требуемый командной оболочке для выполнения
			внешней программы;
	'shellquote'    тип кавычек в которые заключаются команды;
	'shellxquote'   тип кавычек в которые заключаются команды и
			перенаправление вывода;
	'shelltype'     тип оболочки (только для Amiga);
	'shellslash'    использовать наклонную черту в командах
			(только для MS Windows и подобных систем);
	'shellredir'    строка, используемая для перенаправления вывода
			команд в файл.

В UNIX-подобных системах не должно возникнуть сложностей, потому что там всего
два основных типа оболочки: sh-подобные и csh-подобные. Редактором Vim
проверяется значение параметра 'shell' и автоматически устанавливаются
остальные параметры, значения которых зависят от того, встречается ли в
параметре 'shell' строка «csh».
    В системах MS Windows присутствует много различных оболочек и возможно,
потребуется настроить параметры вручную для правильной работы фильтров. За
дополнительной информацией по этим параметрам обращайтесь к документации.


СЧИТЫВАНИЕ ВЫВОДА КОМАНД

Чтобы получить содержимое текущего каталога и вставить эту информацию в файл,
используйте следующие команды:

в UNIX-подобных системах

>
	:read !ls
<

в MS Windows

>
	:read !dir
<

Вывод команды "ls" или "dir" перехватывается редактором и вставляется
непосредственно в текст под строкой с кареткой. Это аналогично чтению файла, с
тем исключением, что используется команда `!` для указания команды, которую
нужно выполнить.
    Для команд можно задавать аргументы и использовать диапазон для указания
позиции, в которой редактором Vim должен быть помещён вывод. Например,

>
	:0read !date -u
<

будет вставлена текущая дата и время в формате UTC в верхней строке файла
(если в системе есть команда date, и она принимает аргумент "-u"). Обратите
внимание на различие между командой "!!date", по которой заменяется строка в
тексте, и командой ":read !date", по которой вставляется строка.


ПЕРЕДАЧА ТЕКСТА КОМАНДЕ

В UNIX-подобных системах команда "wc" используется для подсчёта слов. Чтобы
подсчитать слова в текущем окне, введите

>
	:write !wc
<

Используется всё та же команда ":write", но вместо названия файла указывается
команда `!` и название используемой внешней команды. В этом случае текст будет
передан внешней команде в виде стандартного ввода. Вывод команды может
выглядеть так:

	4      47     249 ~

Команда "wc" не очень многословна. Это означает, что в файле 4 строки, 47 слов
и 249 символов.

Будьте осторожны, чтобы не ввести

>
	:write! wc
<

иначе текст будет записан в файл «wc» в текущем каталоге в обход всех
проверок. Пробел имеет здесь большое значение!


ОБНОВЛЕНИЕ ЭКРАНА

Если внешняя команда вывела сообщение об ошибке, то это может нарушить
отображение текста на экране. В редакторе Vim, для эффективной работы,
обновляются только те части экрана, которые в этом нуждаются, поэтому о том,
что внешняя программа вывела на экран сообщение, в редактор ни как не
передаётся. Чтобы в редакторе Vim обновить содержимое окна, нажмите комбинацию
клавиш

>
	CTRL-L
<

==============================================================================

Следующая глава: |usr_11.txt|  Восстановление после аварийных ситуаций
Авторские права: см. |manual-copyright|
© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

vim:tw=78:ts=8:noet:ft=help:norl:
